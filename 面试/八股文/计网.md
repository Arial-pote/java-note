计算机网络：

工作中接触的以应用层的协议为主



## 重点掌握：

1. TCP/IP协议体系的认知（分层，一部分处于用户态（应用层），一部分处于内核态（数据链路、网络、传输），层与层的透明性、传输对等）

1. 链路层

   1. 以太网帧的格式
   1. MTU的概念（最大传输单元）
   1. ARP协议和RARP协议（了解ARP的报文格式，ip和mac地址互查的机制，掌握一下ARP缓存的原理）（跟网卡有关？）

1. 网络层

   1. IP协议：

      1. 掌握IP的首部格式

         > 16分片标识、DF不分片标志、MF更多分片标志、13位片偏移，8位生存时间TTL，16位的首部检验和

      1. 掌握IP的分片

         > 给很长的数据包，画分片情况，如何避免（在应用层or传输层），分片的顺序，接收端如何确定所有的分片都到达

      1. 路由表字段的含义

         > <img src="https://s2.loli.net/2022/07/09/bEvXcRNIkYxG9go.png" alt="image-20220228234313594" style="zoom: 67%;" />

   1. ICMP协议（较次要）

      1. 掌握报文格式
      1. 分类：查询 + 差错
      1. 两种查询报文 + 五种差错报文

1. 传输层

   1. UDP协议，次要一点，掌握无连接、不可靠特点和首部各个字段

   1. **掌握TCP协议**

      1. 特点 + 首部字段（序号、确认号、……） + 可靠机制
      1. 连接控制 ： 三次握手，四次挥手，同时打开，同时关闭，半关闭（可能问到为什么需要）
      1. 流量控制机制：滑动窗口,慢启动，拥塞避免，快速重传，快速恢复
      1. 超时重传机制（定时器）

      <TCP UDP为什么存在尾包头？>

1. 应用层

   1. 掌握DNS协议
      1. 名字空间
      1. 指针查询（反向查找或逆向解析）基本原理
      1. DNS缓存
   1. FTP协议（活化石）：
      1. 控制流和数据流（为什么需要）
      1. 两种工作模式： PASV 和 PORT
      1. 各种指令和响应码
      1. 断点续传和匿名FTP的概念
   1. HTTP协议： 
      1. 报文格式：请求报文，响应报文，请求头各种字段，响应头各种字段
      1. HTTP状态码
   1. HTTPS协议
      1. 握手的详细过程
      1. 摘要算法，数字签名，数字证书的原理和过程

------

## 概述：

客户服务器方式CS client server；
对等连接方式P2P；

数据交换方式：电路、报文、分组交换；

网络使用分组交换方式：Packet Switching

#### 计算机网络分类：

按作用范围：

1. 广域网 WAN（多个城市连接的网）
1. 城域网 MAN（覆盖一个城市）
1. 局域网 LAN（一间教室的网、学校的网）
1. 个人区域网 PAN（个人设备用交换机连接）
1. 新的理解：使用了广域网技术的网是广域网，不按照网络覆盖范围区分

#### 计算机网络的性能：

1. 速率：连接在计算机网络上的主机在<u>数字信道</u>上传送数据位数的速率，也称为data rate 或bit rate，单位是b/s,kb/s,Mb/s,Gb/s；

1. 带宽：数据通信领域中，数字信道所能传送的最高数据率；（网卡可以看带宽）

1. 吞吐量：在单位时间内通过某个网络的数据量 单位b/s,Mb/s;(所有连接本机的数字信道的流量加起来等于本机的吞吐量)

1. 时延：

   1. 发送时延：数据块长度（bit）/信道带宽（bit/s）【类似火车站出战】
   1. 传播时延：信道长度（s）/信号在信道上的传播速率（m/s）
   1. 处理时延：选择路径时间
   1. 排队时延：排队等待前面的数据包发送的时间

   <img src="https://s2.loli.net/2022/07/09/G4iyk68uQd1MK9Y.png" alt="image-20220301122857265" style="zoom:67%;" />

1. 时延带宽积：传播时延*带宽

1. 往返时间RTT：

1. 利用率：$D=\frac{D_0}{1-U}$  $D_0$表示网络空闲时的时延，D表示网络当前时延，U表示信道利用率；

<时间处即为时延>

### 一些常用的标准：

- ISO：国际标准化组织
- OSI/RM：互联网法律上的国际标准
- TCP/IP suite 因特网事实上的国际标准
- Network Protocols： 数据交换遵循的规则、标准或规定；
- 网络体系结构：计算机网络各层及其协议的集合；

<img src="https://s2.loli.net/2022/07/09/mNaJK1ME5bPwHdn.png" alt="image-20220301192852138" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/07/09/1V7K3Eqvi2NI4yg.png" alt="image-20220301125337450" style="zoom: 50%;" />

```
netstat -n #查看所有session会话（可以用来查木马）
netstat -nb #查看会话同时带发起会话的程序的姓名 
```

五层协议对应的数据单元：

<img src="https://s2.loli.net/2022/07/09/au1nBX6fYdgNqmR.png" alt="image-20220301193132698" style="zoom: 33%;" />

<img src="https://s2.loli.net/2022/07/09/lfVwmpTCnFQHgtv.png" alt="image-20220301193302358" style="zoom: 33%;" />

## 物理层：

信道：一般表示向一个方向传送信息的媒体。平常的通信路线往往包含一个发送信息的信道和一个接受信息的信道；

分类：单工通信（只能单向传输）、半双工通信（通信的双方可以互传但不能同时互传）、全双工通信（通信的双方可以同时发送以及接受）。

信道复用（multiplexing）：

1. 频分复用：（Frequency Division Mutiplexing）

1. 时分复用：（Time Division Mutiplexing）缺点：造成浪费->改进为统计时分复用

1. 波分复用、码分复用；

   这是静态划分信道，不适合如今的互联网（不够智能），如今以太网主要用动态媒体介入控制（多点接入）——随机接入（主要被以太网采用）

## 数据链路层：

<img src="https://s2.loli.net/2022/07/09/Vg1AvZ8ueXxR2KF.png" alt="image-20220301201830548" style="zoom: 33%;" />

数据链路层主要使用的信道：==点对点信道==和==广播信道==；（点对点信道不使用ARP）

链路层传输单元：==帧（frame）==

数据层传输的三个基本问题：封装成帧、透明传输、差错控制

#### 封装成帧：

在数据包的前后分别添加首部和尾部然后就构成了一个帧，首部尾部的重要作用就是进行==帧定界==；

<img src="https://s2.loli.net/2022/07/09/zPUoZ1gQKiA2MlV.png" alt="image-20220301204143659" style="zoom: 33%;" />

> <以太网MTU最大不能超过1500Byte，最小64Byte>
> <如果接收端只收到帧的头部or尾部，就会丢弃该帧>

#### 透明传输：

数据部分出现了帧结束符/开始符，为了不使该帧被丢弃，发送端的数据链路层在将数据发往网络层前插入转义字符，也就是字节填充（byte stuffing）或者字符填充（character stuffing）。接收端的数据链路层则在将数据发往上层前删除插入的转义字符。

<img src="https://s2.loli.net/2022/07/09/o59ZEOdNJMavHxU.png" alt="image-20220301204536616" style="zoom: 33%;" />

<img src="https://s2.loli.net/2022/07/09/4yolc8WD3xH7jNv.png" alt="image-20220301204627081" style="zoom:33%;" />

#### 差错控制：

循环冗余检验CRC

注：计算规律是相同得0，不同得1；最后传输是原数据加余数；除数的同步是由数据链路层实现；
余数称为FCS，帧检验序列；

<img src="https://s2.loli.net/2022/07/09/RgDmihSXfBvqaU2.png" alt="image-20220301205622361" style="zoom:50%;" />

但CRC不能纠错，而且可能差错失败

全世界用得最多的数据链路层协议是点对点协议：PPP（Point to Point Protocol）

ppp帧：

<img src="https://s2.loli.net/2022/07/09/9GSZg4kfBw6D5Vu.png" alt="image-20220301211239979" style="zoom: 33%;" />

7E 转换为二进制 0111 1110

A 、C是固定的，因为点对点传输不需要地址

ppp协议不使用序号和确认机制；

### 载波监听多点接入/碰撞检测：

以太网使用CSMA/CD（Carrier Sense Mutiple Access with Collision Detection）

多点接入表示许多计算机以多点接入的方式连接在一根总线上，载波监听表示一个站在发送数据前先检测一下总线上是否有其他计算机在发送数据，如果有则等待一个随机时间再发。

- 半双工通信

### 以太网：

以太网是局域网的一种技术，即星型拓扑结构局域网。以前数据链路层被拆分为两个子层LLC（Logical Link Control 逻辑链路控制）和MAC（Medium Access Control：媒体接入控制）。现在基本只使用MAC层。

以太网提供的服务是==不可靠的交付，收到有差错的数据帧时丢弃该帧==；高层发现丢失数据重传时，以太网不知道这是一个重传的帧，而是当作一个新的数据帧来处理；

#### MAC地址：

在局域网中，硬件地址又称为物理地址，或MAC地址。802标准所说的“地址”严格来讲应该是每一个站“名字”或标识符。IEEE的注册管理机构向厂家分配地址字段的前三个字节（高24位），后三字节（低24位）由厂家自行分配。

用于唯一标识网络适配器（网卡）。一台主机拥有多少网络适配器就拥有多少mac地址，一般由无线和有线两个网络适配器；

```
ipconfig -all # 查看本机mac地址
```

适配器从网络上每收到一个MAC帧就首先用硬件检查MAC帧中的MAC地址。如果是发往本站则收下，否则丢弃。帧的类型包括以下三种：

1. 单播（unicast）帧（一对一）
1. 广播（broadcast）帧（一对全体）
1. 多播（multicast）帧（一对多）

#### 以太网帧（MAC帧）

<img src="https://s2.loli.net/2022/07/09/TYGwnWN7ZMpRgj2.png" alt="image-20220302095648399" style="zoom: 33%;" />

类型指明是什么协议；数据最小为46byte，因为整个帧最小为64byte；

#### 交换机：

交换机拥有自学习能力，学习的是交换表的内容，交换表中存储着mac地址到接口的映射；

下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。

<img src="https://s2.loli.net/2022/07/09/1bVzfECHQOirmG4.png" alt="image-20220302123352430" style="zoom: 67%;" />



### ARP  地址解析协议：

Address Resolution Protocol：

网络层实现主机间的通信，链路层实现具体每段链路的通信。<u>在此过程中IP数据报的源地址和目的地址始终不变，而MAC地址随着链路的改变而改变</u>。==ARP 为 IP 地址到对应的硬件地址提供动态映射==，实现由IP地址获得MAC地址；

#### 实现：

==每个主机都有一个ARP的高速缓存==，里面有本局域网上的各主机和路由器的IP地址到MAC地址的映射。如果主机A知道主机B的IP地址，但是ARP高速缓存中没有该IP地址到MAC地址的映射，此时主机A通过广播的方式发送ARP请求分组，主机B收到该请求后会发送ARP响应分组给主机A告知其MAC地址，随后主机A向高速缓存中写入主机B的IP地址到MAC的映射。

## 网络层：

网络层向上提供简单灵活的、无连接的、不可靠的数据报服务；

- **不可靠**：指的是不能保证数据报能成功地到达目的地。发生错误时候，丢弃该数据包，发送 ICMP 消息给信源端。 ==可靠性由上层提供。==
- **无连接**：IP 不维护关于后续数据报的状态信息。IP 数据可以不按顺序发送和接收。A 发送连续的数据报，到达 B 不一定是连续的，来回路由选择可能不一样，路线也不一样，到达先后顺序也不一样。

### IP数据报格式：

<img src="https://s2.loli.net/2022/07/09/mnldNOq5k7xZIvU.png" alt="image-20220302123653452" style="zoom:67%;" />

- 版本：（4）IPV4和（6）IPV6两个值；
- 首部长度：占 4 bit，表达首部长度的大小，**值为1表达的是4byte的长度**。因为固定部分为20字节，因此最小为5，最大15；如果可选字段的长度不为4字节，则用尾部的“填充”使其达到；
- 区分服务：用来获得更好的服务，一般情况下不使用；
- 总长度：首部长度+数据部分长度，最大为$2^{16}-1$；
- **生存时间（TTL，Time to live）**：防止无法交付的数据报在互联网中不断兜圈子，以路由器跳数为单位，**TTL为0时丢弃；**
- 协议：指出携带的数据交由哪个上层数据处理，例如ICMP，TCP，UDP等；
- 首部检验和：因为数据报每经过一个路由器，都要重新计算检验和，因此只计算首部部分可以减少计算的工作量；
- **标识（identification）：在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符**
  - 标志（flag）：占 3 位。第一位未使用，其值为 0。第二位称为 DF（不分片），表示是否允许分片。取值为 0 时，表示允许分片；取值为 1 时，表示不允许分片。第三位称为 MF（更多分片），表示是否还有分片正在传输，设置为 0 时，表示没有更多分片需要发送，或数据报没有分片。

- **片偏移：和标识符一起，用于发生分片的情况。片偏移的单位为8字节；**

<img src="https://s2.loli.net/2022/07/09/Hk4ZQirMh1tyRp3.png" alt="image-20220302125103804" style="zoom:67%;" />

### IP地址的编制方式：

IP地址：32位的二进制；

1. 分类：

   <img src="https://s2.loli.net/2022/07/09/5R2ZGJdtzTEOeSg.png" alt="image-20220302125350330" style="zoom: 67%;" />

1. 子网划分：

   1. 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。
   1. 注意，外部网络看不到子网的存在

1. 无类域间路由选择（Classless Inter-Domain Routing）：

   1. 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。（使网络的划分更为方便）
   1. ==IP 地址 ::= {< 网络前缀号 >, < 主机号 >} / 网络前缀所占位数==，例如 128.14.35.7/20 表示前 20 位为网络前缀。
   1. <u>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</u>
   1. 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 **构成超网** 。
   1. 在路由表中的项目由 “网络前缀”和“下一跳地址” 组成，在查找时可能会得到不止一个匹配结果，应当采用==最长前缀匹配==来确定应该匹配哪一个
   1. [例子](https://www.cnblogs.com/hark0623/p/6547432.html)

### 网际控制报文协议 ICMP

Internet Control Message Protocol，TCP/IP协议族的一个子协议，用于==在IP主机、路由器之间传递控制信息。==控制信息是指网络不通、主机是否可达、路由是否可用等网络本身的消息。这些控制信息虽然并不传输用户数据，但是对用户数据的传输起到重要的作用。

<img src="https://s2.loli.net/2022/07/09/ar9dczUIXsMpCqL.jpg" alt="图片" style="zoom: 50%;" />

 `ICMP`协议头包含 4个字节，头部主要用来说明类型和校验 `ICMP`报文。

<img src="https://s2.loli.net/2022/07/09/37W6mNxQV4KHaer.jpg" alt="图片" style="zoom: 50%;" />

ICMP报文分为两种类型，差错报告报文和询问报文。

#### 差错报文：

<img src="https://s2.loli.net/2022/07/09/y6tdiaWBfxFMkG5.png" alt="image-20220303094750308" style="zoom:67%;" />

1. 终点不可达：网络不可达，主机不可达，协议不可达，端口不可达，需要分片但DF比特已置为1，以及源路由失败等六种情况，其代码字段分别置为0至5。
1. 源站抑制：路由器或主机由于拥塞而丢弃数据报时，除丢弃该数据报外，还要向源站发送源站抑制报文，使源站知道应当将数据报的发送速率放慢。
1. 时间超过：当路由器收到生存时间为0的数据报时，丢弃该数据并向源站发送时间超过报文；当目的站在预先规定的时间内不能收到一个数据报的全部数据报片时，丢弃已收到的报文片并向源站发送时间超过报文；
1. 参数问题：当路由器或目的主机所受到的数据报的首部中的字段的值不正确时，丢弃该数据报并向源站发送参数问题报文；
1. 改变路由（重定向）：路由器将发送改变路由报文给主机，让它知道下次该发往其他路由；

#### 查询报文：

<img src="https://s2.loli.net/2022/07/09/VDT7QCMKLHJfYbu.png" alt="image-20220303094810771" style="zoom: 67%;" />

可以应用于ping；

1. 回送请求和回答：主机或路由器向一个特定的目的主机发出的询问。收到此报文的机器必须给源主机发送ICMP回送应答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。
1. 时间戳请求和回答：系统向另一个系统查询当前的时间。该ICMP报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间只能提供秒级的分辨率。
1. 掩码地址请求和回答：使用ICMP地址掩码请求报文可向子网掩码服务器得到某个接口的地址掩码。系统广播它的ICMP请求报文。ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回，这样，发送端就可以把应答与请求进行匹配。
1. 路由器询问和通过：了解连接在本网络上的路由器是否正常工作。主机将路由器询问报文进行广播（或多播）。收到询问报文的一个或几个路由器就使用路由器通过报文广播其路由选择信息

### 应用：

#### ping：

Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

#### Traceroute：

Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。

Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。

- 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；
- 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。
- 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。
- 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

虚拟专用网VPN：

由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。

下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。

<img src="https://s2.loli.net/2022/07/09/QwXY8UJk3p9d45H.png" alt="image-20220303101523057" style="zoom:50%;" />

## 传输层：

传输层是进程间的通信；

### UDP 用户数据报协议 ：

User Datagram Protocol，是无连接的，不可靠，没有拥塞控制，==面向报文（对于应用层传下来的报文不合并也不拆分，只是添加UDP首部）==，支持一对一、一对多，多对多和多对一的交互通信；



<img src="https://s2.loli.net/2022/07/09/EFcMLSy1ZsbRQAU.png" alt="image-20220303102502726" style="zoom:50%;" />

> - 长度：UDP的整个数据报的长度，最大长度是$(2^{16}-1)-20=65535-20$
> - 伪首部帮助计算校验和，其中0是8位保留字节，17是传输层协议号（UDP是17，传输层是8）

众所周知，IP首部的校验和会校验IP，那么为何在tcp校验和还需要校验IP呢？<u>因为数据包经过中间器件（路由器）的时候，这些中间器件可能会修改IP首部的内容，例如同时修改目的IP和IP首部校验和。</u>（e.g 上述例子中的虚拟专用网vpn）这样一来将导致错误的接收方接收到该数据包。因此在TCP的伪首部加上IP地址，可以防止错收报文。既然中间器件可以修改IP首部的信息，为什么不将TCP的校验和一起修改呢，这样不就使得接收方误收数据包吗？当然可以，但是中间器件一般不会修改TCP层的信息。

### TCP 传输控制协议 ：

Transmission Control Protocol，是面向连接的，提供可靠交互的，有流量控制、拥塞控制，提供全双工通信，==面向字节流（把应用层传下来的数据看为字节流，把字节流组织成大小不等的数据块）==，每一条TCP连接只能是点对点的；

<img src="https://s2.loli.net/2022/07/10/FEAcoBseCIHgQK2.png" alt="image-20220303104351505" style="zoom:67%;" />

> - **序号 seq**：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
> - **确认号 ack** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
> - **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是**首部的长度。**
> - **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
> - **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
> - **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
> - **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

#### 三次握手：

<img src="https://s2.loli.net/2022/07/10/WqNY4gAeUcI5DFB.png" alt="image-20220303105137872" style="zoom:67%;" />

**三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

#### 四次挥手：

<img src="https://s2.loli.net/2022/07/09/19YPWBnhTkEyRmf.png" alt="image-20220303105450629" style="zoom:67%;" />

> 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。
>
> - A 发送连接释放报文，FIN=1。
> - B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。
> - 当 B 不再需要连接时，发送连接释放报文，FIN=1。
> - A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
> - B 收到 A 的确认后释放连接

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了==让服务器端发送还未传送完毕的数据==，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 **2MSL**。这么做有两个理由：

- **确保最后一个确认报文能够到达**。如果 B 没收到 A 发送来的确认报文，那么就会重新发送==连接释放请求报文==，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了==让本连接持续时间内所产生的所有报文都从网络中消失==，使得下一个新的连接不会出现旧的连接请求报文。

#### 超时重传：

- RTT（Round Trip Time）：往返时延，也就是**数据包从发出去到收到对应 ACK 的时间。**RTT 是针对连接的，每一个连接都有各自独立的 RTT。
- RTO（Retransmission Time Out）：重传超时，也就是前面说的超时时间.

如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。一个报文段从发送再到接收到确认所经过的时间称为**往返时间 RTT**，加权平均往返时间 RTTs 计算如下：
$$
RTTs=(1-a)* (RTTs)+a*RTT
$$
其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响,超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：
$$
RTO=RTTs+4*RTT_d
$$
$ RTT_d $为偏差的加权平均值。

#### 滑动窗口：

窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己窗口大小，发送方根据这个值和其他信息设置自己窗口大小。

==发送窗口内的字节都允许发送，接收窗口内的字节都允许接收。==如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已经发送并且确认接受的状态；接收滑动窗口类似，接收窗口左部字节已经发送并且确认交付主机，就向右滑动接收窗口。

接收窗口只会对窗口内最后一个==按序到达==的字节进行确认，例如接收窗口已经收到的字节位为{31，34，35}，其中{31}按序到达，而{34，35}就不是，因此只对字节31进行确认。发送方得到一个字节的确认后，就知道这个字节之前的字节都已经被接收。

<img src="https://s2.loli.net/2022/07/09/G4OjMefaPSER5bs.png" alt="image-20220305105013060" style="zoom: 67%;" />

#### 流量控制：

流量控制是为了控制发送方发送速率，保证接收方来得及接收。==接收方发送的确认报文中的窗口字段可以用来控制发送方窗口的大小，从而影响发送方的发送速率==。将窗口字段设置为0，则发送方不能发送数据。

#### 拥塞控制：

如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

<img src="https://s2.loli.net/2022/07/09/1QGCnHDgrbUVjf9.png" alt="image-20220305105412910" style="zoom:67%;" />

TCP主要通过四个算法来进行拥塞控制：**慢开始、拥塞避免、快重传、快恢复；**

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送发能发送多少数据的是发送方窗口。

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然TCP的窗口基于字节，但是这里设窗口的大小单位为报文段；

<img src="https://s2.loli.net/2022/07/09/mv4OMPV27Jhbasx.png" alt="image-20220305110604661" style="zoom:67%;" />

**慢开始与拥塞避免**：

发送的最初执行慢开始（不是指增长速度慢，而是开始的值小），令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。
如果出现了**超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。**

==快重传与快恢复：==

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
**在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。**例如收到三个 M2，则 M3 丢失，立即重传 M3。
在这种情况下，**只是丢失个别报文段，而不是网络拥塞。因此执行快恢复**，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。
慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

<img src="https://s2.loli.net/2022/07/09/EMeLcA4sJB9lvyn.png" alt="image-20220305110941972" style="zoom: 67%;" />



### TCP的粘包和拆包

**粘包产生的原因**：TCP/IP协议中，无论发送多少数据，总是要在数据(DATA)前面加上协议头(TCP Header+IP Header)，同时，对方接收到数据，也需要发送ACK表示确认。

**即使从键盘输入的一个字符，占用一个字节，可能在传输上造成41字节的包，其中包括1字节的有用信息和40字节的首部数据。这种情况转变成了4000%的消耗，这样的情况对于重负载的网络来是无法接受的。称之为"糊涂窗口综合征"**。

为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。

Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。

#### 为什么UDP没有粘包？

粘包拆包问题在数据链路层、网络层以及传输层都有可能发生。日常的网络应用开发大都在传输层进行，由于==UDP有消息保护边界==，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。

---

**拆包产生的原因**：MTU是以太网传输数据方面的限制，每个以太网帧最大不能超过1518bytes。刨去以太网帧的帧头(DMAC+SMAC+Type域）14Bytes和帧尾(CRC校验)4Bytes，**那么剩下承载上层协议的地方也就是Data域最大就只能有1500Bytes这个值 我们就把它称之为MTU**。

MSS是在MTU的基础上减去网络层的IP Header和传输层的TCP Header的部分，这就是TCP协议一次可以发送的实际应用数据的最大大小。

`MSS = MTU(1500) -IP Header(20 or 40)-TCP Header(20)`

由于IPV4和IPV6的长度不同，在IPV4中，以太网MSS可以达到1460byte；在IPV6中，以太网MSS可以达到1440byte。

**发送方发送数据时，当SO_SNDBUF中的数据量大于MSS时，操作系统会将数据进行拆分，使得每一部分都小于MSS，也形成了拆包，**然后每一部分都加上TCP Header，构成多个完整的TCP报文进行发送，当然经过网络层和数据链路层的时候，还会分别加上相应的内容。

---

**解决方法：**

自定义通信协议(RPC)：

#### **3.1 定长协议**

定长协议就是指定一个报文的必须具有固定的长度。例如，我们规定每3个字节，表示一个有效报文，如果我们分4次总共发送以下9个字节：

```javascript
  +---+----+------+----+  | A | BC | DEFG | HI |  +---+----+------+----+
```

​     那么根据协议，我们可以判断出来，这里包含了3个有效的请求报文，如下：

```javascript
   +-----+-----+-----+   | ABC | DEF | GHI |   +-----+-----+-----+
```

在定长协议中：

- 发送方，必须保证发送报文长度是固定的。如果报文字节长度不能满足条件，如规定长度是1024字节，但是实际需要发送的内容只有900个字节，那么不足的部分可以补充0。因此定长协议可能会浪费带宽。
- 接收方，每读取到固定长度的内容时，则认为读取到了一个完整的报文。

#### **3.2 特殊字符分隔符协议**

在包尾部增加回车或者空格符等特殊字符进行分割 。例如，按行解析，遇到字符\n、\r\n的时候，就认为是一个完整的数据包。对于以下二进制字节流：

```javascript
   +--------------+   | ABC\nDEF\r\n |   +--------------+
```

那么根据协议，我们可以判断出来，这里包含了2个有效的请求报文

```javascript
   +-----+-----+   | ABC | DEF |   +-----+-----+
```

​        在特殊字符分隔符协议中：

- 发送方，需要在发送一个报文时，需要在报文尾部添加特殊分割符号；
- 接收方，在接收到报文时，需要对特殊分隔符进行检测，直到检测到一个完整的报文时，才能进行处理。

**在使用特殊字符分隔符协议的时候，需要注意的是，我们选择的特殊字符，一定不能在消息体中出现，否则可能会出现错误的拆包。**例如，发送方希望把”12\r\n34”，当成一个完整的报文，如果是按行拆分，那么就会错误的拆分为2个报文。一种解决策略是，发送方对需要发送的内容预先进行base64编码，由于base64编码只包含64个字符：0-9、a-z、A-Z、+、/，我们可以选择这64个字符之外的特殊字符作为分隔符。

**提示：**netty中提供了DelimiterBasedFrameDecoder根据特殊字符进行解码。事实上，我们熟悉的的缓存服务器redis，也是通过换行符来区分一个完整的报文。

#### **3.4 序列化**

序列化本质上已经不是为了解决粘包和拆包问题，而是为了在网络开发中可以更加的便捷。在变长协议中，我们看到可以在实际要发送的数据之前加上一个length字段，表示实际要发送的数据的长度。**这实际上给我们了一个很好的思路，我们完全可以将一个对象转换成二进制字节，来进行通信，例如使用一个Request对象表示请求，使用一个Response对象表示响应**。（proto）

## 应用层：

###  DNS 域名系统：

Domain Name System是一个==分布式数据库==，提供了主机名和IP地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那份数据。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。

<img src="https://s2.loli.net/2022/07/09/QzxNriPRX9pFd38.png" alt="image-20220305111856386" style="zoom:67%;" />

DNS可以使用UDP或者TCP进行传输，==使用的端口号都为53。大多数情况下DNS都使用UDP进行传输==，这就要求域名解析器和域名服务器都必须自己处理超时重传从而保证可靠性。在这两种情况下会使用TCP进行传输。

- 如果传回的响应超过512个字节（UDP最大只支持512字节的数据）
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）

主机解析域名的顺序：

1. 浏览器缓存
1. 找本机的 hosts 文件
1. 路由缓存
1. 找 DNS 服务器(本地域名、顶级域名、根域名) 
   1.  迭代查询、递归查询

### FTP 文件传送协议：

File Transfer System使用TCP进行连接，它需要两个连接来传送一个文件：

1. 控制连接：服务器打开==端口号21==等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。
1. 数据连接：用来传送一个文件数据

根据数据连接是否是服务端主动建立，FTP有主动和被动两种模式：

- 主动模式：服务端主动建立数据连接，其中服务器端的端口号为20，客户端的端口号随机，但是必须大于1024，因为0~1023是熟知的端口号

  <img src="https://s2.loli.net/2022/07/09/B2FJqkPonH4uCj7.png" alt="image-20220307101228278" style="zoom:67%;" />

- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户自己指定，服务端的端口号随机。

  <img src="https://s2.loli.net/2022/07/09/ILJXqztuHR4cghx.png" alt="image-20220307101411463" style="zoom:67%;" />

主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务端的安全性减弱，因为开放了过多的端口。

### DHCP 动态主机配置协议：

Dynamic Host Configuration Protocol 提供了即插即用的连网方式，用户不再需要手动配置IP地址等信息。

配置的内容：IP地址，子网掩码、网关IP地址。

DHCP 工作过程如下：

1. 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。
1. DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。
1. 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。
1. DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。

<img src="https://s2.loli.net/2022/07/10/QbzH9EB2cgRwXjM.png" alt="image-20220307103238945" style="zoom:67%;" />

### HTTP：

Hypertext Transfer Protocol：顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。并且，HTTP 是一个==无状态（stateless）==协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。

 HTTP 协议通信过程：HTTP 是应用层协议，它以==TCP（传输层）作为底层协议，默认端口为 80.== 通信过程主要如下：

1. 服务器在 80 端口等待客户的请求。
1. 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
1. 服务器接收来自浏览器的 TCP 连接。
1. 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
1. 关闭 TCP 连接。

#### 请求报文：

<img src="https://s2.loli.net/2022/07/09/GW9B2wrVSNEPJbY.png" alt="img" style="zoom:67%;" />

##### 请求行

请求行：`GET /java.html HTTP/1.1`    请求方式/资源名称/使用的HTTP版本号：

**请求方式：**

<u>POST,GET</u>,HEAD,OPTIONS,DELETE,TRACE,PUT。

一般来说，当我们点击超链接，**通过地址栏访问都是get请求方式。通过表单提交的数据一般是post方式**。可以简单理解GET方式用来查询数据,POST方式用来提交数据，get的提交速度比post快

> **get 和 post区别：**
>
> 1. get用于请求服务器资源，Post用于提交服务器数据
> 1. Get传递的请求数据按照key-value的方式放在URL后面，在网址中可以直接看到，使用?分割URL和传输数据，传输的参数之间以&相连，如：login.action?name=user&password=123。所以安全性差。POST方法会把请求的参数放到请求头部和空格下面的请求数据字段就是请求正文（请求体）中以&分隔各个字段，请求行不包含参数，URL中不会额外附带参数。所以安全性高。
> 1. 通常GET请求可以用于获取轻量级的数据，而POST请求的内容数据量比较庞大些。Get：1~2KB。get方法提交数据的大小直接影响到了URL的长度，但HTTP协议规范中其实是没有对URL限制长度的，限制URL长度的是客户端或服务器的支持的不同所影响。

**协议版本号：**

HTTP1.0协议中，客户端与web服务器建立连接后，只能获得==一个==web资源【短连接，获取资源后就断开连接】
HTTP1.1协议，允许客户端与web服务器建立连接后，在一个连接上获取==多个==web资源【保持连接】

##### 请求头：

```http
GET / HTTP/1.1              //请求行
Host: www.enjoytoday.cn      //HTTP1.1必须有Host字段。
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.84 Safari/537.36
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: http://www.enjoytoday.cn/posts/326
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
Cookie: bdshare_firstime=1466032270994; UM_distinctid=15c4ef2ac4e2e4-0d13269271b947-1b2a120b-1fa400-15c4ef2ac4f7b5; un=aGZjYWk=; comment_author=aGZjYWk=; comment_author_email=1710600212@qq.com; comment_author_url=http://www.enjoytoday.cn; c_id=dUhIaTlndmc4MVVYbjRQTGxMRTotMTpFODg3QjgzQjg1NjgxQjQxRUYxNjg2QzJFRkMyQjI2QQ==; JSESSIONID=ADBC8C3DADF6C815D778450C193C6637.ajp13_worker; Hm_lvt_ce55bfda158556585a8b7b246346c8ba=1498560244,1498739070,1498833193,1498917432; Hm_lpvt_ce55bfda158556585a8b7b246346c8ba=1498917597; CNZZDATA1262047894=1598545996-1495973145-%7C1498917578
 
 //报文主体：
username=hfcai&sex=man
```

#### 响应报文：

<img src="https://s2.loli.net/2022/07/09/rUOGHVmF18zoiue.png" alt="img" style="zoom:67%;" />

##### 状态行：

格式： HTTP版本号 + 状态码 + 原因叙述    e.g  `HTTP/1.1 200 OK`

状态码用于表示**服务器对请求的处理结果**，它是一个**三位的十进制数**。响应状态码分为5类

![图片](https://s2.loli.net/2022/07/09/NYSrkUA5JqHDBCc.webp)

##### 响应头

```http
HTTP /1.1 200 OK   //状态行主要给出响应HTTP协议的版本号、响应返回状态码、响应描述，同样是单行显示。
  Date: Sat, 01 Jul 2017 14:51:26 GMT
  Server: Apache/2.4.7 (Ubuntu)
  //响应头部主要是返回一些服务器的基本信息，以及一些Cookie值等
  Set-Cookie: JSESSIONID=84C993F5E433C4DE9BFBA57150FFC065.ajp13_worker;path=/;HttpOnly
  Content-Language: zh-CN
  Vary: Accept-Encoding
  Content-Encoding: gzip
  Content-Length: 7333
  Keep-Alive: timeout=5, max=100
  Connection: Keep-Alive
  Content-Type: text/html;charset=UTF-8
 
  <html>
  <head>
  <title>title of html.</html>
  </head>
  <body>
  <h1>Hello world!</h1>
  </body>
  </html>
```

### HTTPS 

Hypertext Transfer Protocol Secure，HTTP的加强安全版本。HTTPS是基于HTTP的，也是用 TCP 作为底层协议，==并额外使用 SSL/TLS 协议用作加密和安全认证==。默认端口号是 443.

#### SSL/TLS协议：

SSL 指安全套接字协议（Secure Sockets Layer）。其工作原理为：

##### 非对称加密：

SSL/TLS的核心要素。非对称加密采用两个密钥：一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。

> 单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。
>
> 单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。

##### 对称加密：

非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。

因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，**使用非对称加密，对对称加密的密钥进行加密**，保护该密钥不在网络信道中被窃听。这样，==通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。==

##### 数字证书：

然而，由于网络通信的机制，使得公钥的传输极其容易被攻击。为了解决==公钥传输的信赖性问题==，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA默认是受信任的第三方。CA会给每个机构颁发证书，证书存储在服务器上，并附有 CA 的**电子签名**。当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。

数字签名，是 CA 在给服务器颁发证书时，使用==散列+加密==的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：

> CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。
>
> 现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。
>
> 客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。

总结来说，带有证书的公钥传输机制如下：

1. 设有服务器 S，客户端 C，和第三方信赖机构 CA。
1. S 信任 CA，CA 是知道 S 公钥的，S 向 CA 颁发证书。并附上 CA 私钥对消息摘要的加密签名。
1. S 获得 CA 颁发的证书，将该证书传递给 C。
1. C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书山的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。
1. 如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。

![img](https://s2.loli.net/2022/07/09/T1WRyAgCjcp7HQl.png)

### 常用端口

| 应用             | 应用层协议 | 端口号  | 传输层协议 | 备注                        |
| ---------------- | ---------- | ------- | ---------- | --------------------------- |
| 域名解析         | DNS        | 53      | UDP/TCP    | 长度超过 512 字节时使用 TCP |
| 动态主机配置协议 | DHCP       | 67/68   | UDP        |                             |
| 简单网络管理协议 | SNMP       | 161/162 | UDP        |                             |
| 文件传送协议     | FTP        | 20/21   | TCP        | 控制连接 21，数据连接 20    |
| 远程终端协议     | TELNET     | 23      | TCP        |                             |
| 超文本传送协议   | HTTP       | 80      | TCP        |                             |
| 简单邮件传送协议 | SMTP       | 25      | TCP        |                             |
| 邮件读取协议     | POP3       | 110     | TCP        |                             |
| 网际报文存取协议 | IMAP       | 143     | TCP        |                             |

## Web页面请求过程：

1. 对`www.baidu.com`这个网址进行DNS域名解析，得到对应的IP地址
1. 根据这个IP，找到对应的服务器，发起TCP的三次握手
1. 建立TCP连接后发起HTTP请求
1. 服务器响应HTTP请求，浏览器得到html代码
1. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）
1. 浏览器对页面进行渲染呈现给用户
1. 服务器关闭关闭TCP连接

套接字（Socket）：通信的目的地址、使用的传输协议（TCP或UDP）和使用的端口号（此处说明一下，Socket不仅在TCP有，在UDP同样有）。通过将这3个参数结合起来，与一个Socket进行绑定，应用层就可以与传输层一起通过套接字接口区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP/IP交互提供了称为套接字（Socket）的接口。

**1.URL解析：**

是否合法？浏览器之前是否缓存给该URL的页面？

**2.DNS解析:**

![img](https://s2.loli.net/2022/07/09/S67rKlmxAsRFMUc.png)

* 高速缓存：浏览器，操作系统，路由器等都会缓存一些URL对应的IP地址

* 递归解析：输入`www.baidu.com`网址后，首先在高速缓存中查找，没找到去根域名服务器查找，没有再去`com`顶级域名服务器查找，依次类推，直到找到IP地址，然后把它记录在本地告诉缓存中，供下次使用。大致过程就是`.`-> `.com` ->`baidu.com.` -> `www.baidu.com.`其中`.`代表根域名服务器。

* DNS负载均衡：访问`baidu.com`的时候，每次响应的可能并非是同一个服务器（IP地址不同），一般大公司都有成百上千台服务器来支撑访问，DNS可以返回一个**合适的机器的IP**给用户，例如可以**根据每台机器的负载量，该机器离用户地理位置的距离**等等，这种过程就是DNS负载均衡。

**3.建立TCP链接**

三次握手：



四次挥手：

![img](https://s2.loli.net/2022/07/10/OZaVzYgdW1pehUA.png)



**为什么建立连接是三次握手，关闭连接确是四次挥手**

- 建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，**把ACK和SYN放在一个报文里发送给客户端**
- 关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，**己方ACK和FIN一般都会分开发送，从而导致多了一次**



**4.HTTPS的安全加密过程**

![img](https://s2.loli.net/2022/07/09/xsJtfr6PGlE7qCy.png)

**5.MAC地址查询**

这一步主要负责为打包好的`数据+TCP首部+IP首部`寻找传输路线，**找到IP对应的物理机**，这里会用到ARP协议。

1、ARP协议

ARP（Address Resolution Protocol）即地址解析协议， 用于**实现从 IP 地址到 MAC 地址的映射**，即询问目标IP对应的MAC地址。

2、ARP如何交互

ARP协议通过**一问一答**实现交互，但是问和答都有讲究，**问是通过广播形式实现，答是通过单播形式。**

# 题目：

### 1.http和https的区别：

http：（HyperText Transfer Protocol：超文本传输协议），默认工作在TCP协议==80端口==；

https：（HyperText Transfer Protocol Secure：超文本传输安全协议），一种透过计算机网络进行安全通信的传输协议。HTTPS经由http进行通信，但==利用SSL/TLS来加密数据包==。它开发的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私和完整性；默认工作在TCP协议的==443端口==

https原理如下：客户端访问服务器->服务器把数字证书+公用密匙 发给客户端->客户端验证服务器，确保访问的是正确的服务器（不是钓鱼网站）->客户端生产会话密匙并用公用密匙进行加密再次发给服务器->服务器用私人密匙进行解密（也就相当于验证客户端），验证成功建立起一条安全的数据传递通道->服务器把客户端请求的数据打包加密发送给客户端->客户端浏览器接收数据并解析。



它们的区别：

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

### 2.http怎么变成https：

1.申请一个安全证书(SSL证书)：
2.把证书部署到服务器：Nginx的配置目录下
3.修改服务器的config文件
4.将网站链接修改成https的形式

### 3.服务器收到请求后的处理过程：

1. 客户发起情况到服务器网卡；

1. 服务器网卡接受到请求后转交给内核处理；

1. 内核根据请求对应的套接字，将请求交给工作在用户空间的Web服务器进程

1. Web服务器进程根据用户请求，向内核进行系统调用，申请获取相应资源（如index.html）

1. 内核发现web服务器进程请求的是一个存放在硬盘上的资源，因此通过驱动程序连接磁盘

1. 内核调度磁盘，获取需要的资源

1. 内核将资源存放在自己的缓冲区中，并通知Web服务器进程

1. Web服务器进程通过系统调用取得资源，并将其复制到进程自己的缓冲区中

1. Web服务器进程形成响应，通过系统调用再次发给内核以响应用户请求

1. 内核将响应发送至网卡

1. 网卡发送响应给用户

### 4.说一下Ping的具体过程：

ping不是基于TCP或UDP这种传输协议，而是依托于ICMP协议和ARP协议：

![图片](https://s2.loli.net/2022/07/09/LzWJ3o7t6RONVHM.png)

Ping 4次请求和响应结束后，还有一次 B电脑对 A电脑的 ARP请求，这是为什么呢？这里我猜测应该是有 2个原因：

- 由于 `ARP`有缓存机制，为了防止 `ARP`过期，结束后重新更新下 `ARP`缓存，保证下次请求能去往正确的路径，如果 `ARP`过期就会导致出现一次错误，从而影响测试准确性。
- 由于 ping命令的响应时间是根据请求包和响应包的时间戳计算出来的，所以一次 `ARP`过程也是会消耗时间。这里提前缓存最新的 `ARP`结果就是节省了下次 `ping`的 `ARP`时间。

### 5.Cookies和Session的区别：

**cookie** 是一种发送到客户浏览器的==文本串句柄==，并**保存在客户机硬盘**上，用来标识用户。

**session** 其实指的就是访问者从到达某个特定主页到离开为止的那段时间。 Session 其实是利用 Cookie 进行信息处理的，当用户首先进行了请求后，服务端就在用户浏览器上创建了一个 Cookie，以后每次会话都利用Cookie里的id找到用户。（扩展：如果用户禁用了cookie，会利用URL重写的方式进行跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。）

Session是在**服务端**保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是**客户端**保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。















