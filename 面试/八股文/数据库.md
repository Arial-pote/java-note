数据库：

### 概念词汇：

- **元组** ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- **码** ：码就是能唯一标识实体的属性，对应表中的列。
- **候选码** ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，**而其任何子集都不能再标识**，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- **主码** : 主码也叫主键。主码是从候选码中选出来的。 **一个实体集中只能有一个主码，但可以有多个候选码。**
- **外码** : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- **主属性** ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- **非主属性：** 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

## 数据库范式：

**1NF(第一范式)**

属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。**1NF 是所有关系型数据库的最基本要求** ，也就是说关系型数据库中创建的表一定满足第一范式。

**2NF(第二范式)**

2NF 在 1NF 的基础之上，消除了==非主属性对于主码的部分函数依赖==。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。

<img src="https://s2.loli.net/2022/07/09/st7ofe4Mk1dDJSl.png" alt="image-20220313152745318" style="zoom:80%;" />

一些重要的概念：

- **函数依赖（functional dependency）** ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
- **部分函数依赖（partial functional dependency）** ：如果 X→Y，并且存在 X 的一个真子集$ X_0$，使得$ X_0→Y$，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖于（学号，身份证号）；
- **完全函数依赖(Full functional dependency)** ：在一个关系中，若某个非主属性数据项依赖于**全部关键字**称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
- **传递函数依赖** ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。**传递函数依赖会导致数据冗余和异常。**<u>传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中</u>。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。

**3NF(第三范式)**

3NF 在 2NF 的基础之上，消除了非主属性对于码的==传递函数依赖== 。符合 3NF 要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。

**总结**

- 1NF：属性不可再分。
- 2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。
- 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。

### 具体指令：

drop、truncate、delete区别：

- drop(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- truncate (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- delete（删除数据） : `delete from 表名 where 列名=值`，删除某一列的数据，如果不加 where 子句和`truncate table 表名`作用类似。

truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 **truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。**truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。

## 索引：

索引文件是一种辅助存储结构，其存在与否不改变存储表的物理存储结构；但可以提升其访问速度；其 <u>组织方式</u> 有：

1. 排序索引文件（Ordered indices）：按索引字段值的某一顺序组织存储；
1. 散列索引文件（Hash indices）：依据索引字段值使用散列函数分配散列桶的方式存储；
1. 堆文件：
1. 簇状文件：

可以针对不同的属性或属性组合设计索引字段，从而建立不同的索引文件，可建立多个索引文件。索引文件比主文件小很多，通过检索一个小的索引文件（可全部装进内存）快速定位后，再有针对性的读取非常大的主文件有关的记录

有索引时，更新操作必须**同步更新**索引文件和主文件。索引文件再增加了检索效率的同时，也增加了存储空间、是维护负担加重（不仅要维护主文件，还要维护索引文件）

#### 衡量索引性能的好坏：

访问时间、插入时间、删除时间、空间负载、<u>支持存取的有效性</u>（支持属性的限定值or限定范围的值）（即当前值在某一范围内）

对哪些属性建立索引：经常出现在**检索条件、连接条件、分组计算条件中的属性**建立索引；

实际应用索引的基础知识：

- 定义了Table后，如果定义了主键，则系统将自动创建主索引，利用主索引对Table进行快速定位、检索与更新；
- 索引可以由用户创建/撤销
- 索引会被DBMS(data base management system)自动维护
- Table被删除后，定义在该Table上的索引会被自动撤销

```sql
create [unique] index indexname  # unique 表示索引不允许重复
on tablename(colname [asc|desc]{,colname [asc|desc]...});

drop index indexname;
```

#### 聚簇索引：

InnoDB 使用的是聚簇索引，即**数据和索引是在一起的**，树的叶子节点上的data就是数据本身；聚簇索引的数据物理存放方式是和索引顺序是一致的，==所以一个表只能有一个聚簇索引，而非聚簇索引可以有多个==；

> 在InnoDB中，如果表定义了Primary Key，那么PK就是聚簇索引。如果没有PK，那就会找第一个非空的unique列作为聚簇索引。否则，InnoDB就会创建一个隐藏的row-id作为聚簇索引；
>
> 最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整；

优势：

1. 查询通过聚簇索引可以直接获取数据，相比非聚簇索引需要二次查询（非覆盖索引的情况下）效率要高；
1. 聚簇索引对于范围查询的效率很高，因为其数据是按大小排列的；
1. 聚簇索引适合用在排序的场合，非聚簇索引不合适；

劣势：

1. 维护索引代价高，特别是在插入新行或者主键被更新导致要分页的时候。建议在大量插入新行后，选择在负载较低的时段，通过OPTIMIZE TABLE优化表，因为必须==要被移动的行数据可能造成碎片==。使用独享表空间可以弱化碎片。
1. 表因为使用UUID（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引可能比全表查询更慢（因为随机ID的无序性），所以建议使用int的auto_increment作为主键。
1. 如果主键比较大的话，那辅助索引会更大，因为**辅助索引的叶子节点存储的是主键值**；过长的主键值，会导致非叶子节点占用更多的空间。

#### 非聚簇索引：

MYISAM使用的是非聚簇索引，树的子节点上的data不是数据本身而是数据存放的地址，会比一般的B+树多一次IO操作（去相应的地址下取出数据是最后一次IO）。

#### B+树索引：

一种多级索引，平衡的多叉树，且同层级的节点间有指针相互链接。因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。可以使用联合索引，适用于全键值、键值范围和键前缀查找，其中==键前缀查找只适用于最左前缀查找==。如果不是按照索引列的顺序进行查找，则无法使用索引。

在Mysql中，引擎：MYISAM 和 InnoDB 都是使用B+Tree作为索引结构，但两者的实现方式不大一样。==MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。==在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”，MYISAM一个表拥有索引文件和数据文件。

==InnoDB 引擎中，其数据文件本身就是索引文件。==因此他只有一个后缀为`.ibd`的文件。表数据文件本身就是按 B+Tree 组织的一个索引结构，**树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。**这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，==辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。==在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；**在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。**

![image-20220221103632577](https://s2.loli.net/2022/07/09/75f2EBKZ9ptJC8d.png)

> B+树索引可以理解为将从根节点到叶子节点逐层连接存储，因此$P_i$ 比$K_i$的数量多一；
> 非根非叶节点至少具有ceil(m/2)个孩子/指针；m是阶数，即节点可存储索引数
> 根节点的子结点个数至少为2
> 每一个叶子节点最多包含n-1个值，最少包含ceil((n-1)/2)个值；

<img src="https://s2.loli.net/2022/07/09/sMiET8eFbOBmkrq.png" alt="image-20220221104400147" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/07/09/ZybXO8Eqn2MmC17.png" alt="image-20220221105522632" style="zoom:67%;" />

注意：“实际使用”是去除了最后一个指向下一索引块的指针

#### B树索引：

mangoDB

<img src="https://s2.loli.net/2022/07/09/jMBp6Ju948kqOdv.png" alt="image-20220221111621612" style="zoom:67%;" />

<img src="https://s2.loli.net/2022/07/09/M1fKT9bo6piCANy.png" alt="image-20220221112026106" style="zoom:67%;" />

- B+树索引项个数少于B树；
- B树索引字段值不重复出现，而B+树非叶节点上的索引字段至少与叶结点上的索引字段有一次重复；
- B+树指向主文件的指针只存在叶子节点中，而B树在非叶节点与叶子节点中都有；

------

为什么使用B+树：

* B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。

* B+Tree：非叶子节点只存key，大大的减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。



#### 哈希索引：

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需要一次哈希算法就可定位到相当位置；失去了有序性，因此：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

如果是等值查询，那么哈希索引有绝对优势，因为只需要经过一次算法即可找到相应的键值；前提是键值都是唯一的。如果键值不是唯一的，就需要先找到改键所在的位置，然后再根据链表往后扫描，直到找到相应的数据；如果是范围查询检索，那么哈希索引效率极低：原本是有序的键值，经过哈希算法后，有可能变成不连续的了，无法利用索引范围查，也没有办法利用索引完成排序，以及`like'xxx%`这样对模糊查找（本质上也是一种范围查询）；

在有大量重复键值的情况下，由于哈希冲突，哈希索引的效率也是极低的；

### 索引设计的原则：

目标：查询更快、占用空间更小

1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
1. 基数较小的表，索引效果较差，没有必要在此列建立索引
1. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间，如果搜索词超过索引前缀长度，则使用索引排除不匹配的行，然后检查其余行是否可能匹配。
1. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。
1. ==定义有外键的数据列一定要建立索引。==（关联其他的表）
1. 更新频繁字段不适合创建索引
1. 若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)
1. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。
1. 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。
1. 对于定义为text、image和bit的数据类型的列不要建立索引。

## 查询优化：

==MYSQL的覆盖索引和回表：==

**回表：**对于B+树索引来说，如果使用非主键进行查询（该键已建立普通索引），会先通过普通索引处找到其主键信息，再通过主键索引找到聚簇索引中的行信息，这就是所谓的**回表查询**；（查询了两次表，效率较低

如果只需要在一颗索引树上就可以获取SQL所需要的列，就不需要再回表查询，这样查询速度就可以快；

==索引覆盖：==

将要查询的字段，全部建立到联合索引中：（最简单的方法）

```sql
select id,name from user where name='shenjian'; # 需要索引name（id主键
select id,name,sex from user where name='shenjian';# 需要联合索引name、sex
```

> 如何知道查询语句是否命中索引：
>
> `explain select xx from xx where xx`：在前面加一个explain，如果表格的**Extra**显示Using index，则命中索引；若为(NULL)，则未命中；对于命中索引的查询，**type** 为ref，**key** 中为命中的索引名字

应用场景：

1. 全表count查询：`count(name)` 则给name字段建立索引；
1. 列查询回表优化：在`select id,age,name from user where age = 10;`
   建联合索引`idx_age_name(age,name)`即可；
1. 分页查询：`select id,age,name from user order by age limit 100,2;`
   因为name字段不是索引，所以在分页查询需要进行回表查询，此时Extra为Using filesort文件排序，查询性能低下。
   建联合索引`idx_age_name(age,name)`

**注意：**索引不是越多越好，维护索引也需要消耗时间空间；

------

数据库会自动对sql语句进行优化，通过==转换关系代数操作次序==（保证等价性）提高语句执行的效率；[其余常见索引失效场景如下（注意避免提高效率）](https://www.cnblogs.com/wjqhuaxia/p/12832469.html)

## 分页：

一般在客户端实现分页功能的时候，要显示当前页的数据、当前所在页数、临近页面的按钮以及总页数等等。这些数据随着翻页的进行能够动态的变化，为了实现这样的效果，一般会采取两种办法：**真分页**和**假分页**。这样的划分方式是从与数据库的交互方式出发的，是每次翻页时都进行查询还是一次性查出所有的数据。

### 1. 真分页：

真分页指的是每次在进行翻页时都只查询出当前页面的数据，特点就是==与数据库的交互次数较多，但是每次查询的数据量较少，数据也不需要一直保存在内存中。==适用于数据量比较大的场景，数据不适合全量查出的情况。

<img src="https://s2.loli.net/2022/07/09/aSUqGQfBeADgTCF.jpg" alt="img" style="zoom:67%;" />

### 2. 假分页：

假分页指的是对于要显示的==数据一次性全部查出，一直存在在服务端或客户端，在前端进行分页或由服务端控制分页==。将根据当前所在页来计算应该显示的数据所在下标，用循环取出目标数据。只有当会话断开或页面关闭，相应的资源才会被释放。

<img src="https://s2.loli.net/2022/07/09/z69pZ8QmulULnAH.jpg" alt="img" style="zoom:67%;" />

### 3. 缓存层

真分页和假分页都要和数据库进行交互，对于真分页来说不需要担心数据同步的问题，因为每次都是查询出最新的，但是数据库的负担会很重，尤其是用户量大的情况下。假分页可以在一定程度上减轻数据库的压力，但是数据不能及时得到同步，除非重新请求或页面刷新。一般在企业中会有缓存层的存在，既能有效降低数据库的压力，又能及时的进行数据同步。==在对数据库中的数据进行修改后，要将变更后的数据及时同步到缓存层，在进行数据查询时从缓存层获取。==

![img](https://s2.loli.net/2022/07/09/rMy1FAcw4iKVfUq.jpg)

实现分页：LIMIT单参数、LIMIT双参数，分页公式；

```sql
/* 查询前5条数据 */
SELECT * FROM Student LIMIT 5;
/* 查询第1-10条数据 */
SELECT * FROM Student LIMIT 0,10;
/* 查询第11-20条数据 */
SELECT * FROM Student LIMIT 10 OFFSET 10;
/* 获得数据总条数 */
SELECT COUNT(*) FROM Student;
/* 假设每页显示10条，则直接进行除法运算，然后向上取整 */
SELECT CEIL(COUNT(*) / 10) AS pageTotal FROM Student;
```

## 事务：

为什么要并发控制：

事务：

事务是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员**将一系列的数据库操作组合在一起作为一个整体进行操作和控制**，以便数据库管理系统能够提供一致性状态转换的保证；

事务的宏观性：一条或多条SQL语句的一次执行被看作一个事务。

事务的微观性：对数据库的一系列基本操作（读、写）的一个整体性执行；

事务是并发执行的，多个事务从宏观上看是并行执行的，但其微观上的基本操作（读、写）则是可以交叉执行的，==并发控制就是通过事务微观交错执行次序的正确安排，保证事物宏观的独立性、完整性和正确性；==

### ACID 特性：

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。回滚可以用==回滚日志（Undo Log）==来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。
1. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
1. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
1. **持久性**（`Durability`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。系统发生崩溃可以用==重做日志（Redo Log）==进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

<img src="https://s2.loli.net/2022/07/09/vSLowyjKGziaudU.png" alt="image-20220331001653039" style="zoom:67%;" />

### 并发一致性问题：

#### 丢失修改：

一个事务的更新操作被另外一个事务的更新操作替换。

#### 脏读：

当前事务可以读到另外事务未提交的数据。

#### 不可重复读：

在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。（与脏读的区别，当前事务可能已提交）

#### 幻读：

本质上也属于不可重复读的情况，T1 读取某个==范围==的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

在MySQL中，只有InnoDB支持事务，实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，==通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。==

## 锁：

不同的引擎有不同的锁机制，即默认使用不同的锁；

锁的属性：<u>共享和排他，意向共享锁和意向排他锁</u>；

**共享锁(Share Lock)**：共享锁又称读锁，简称S锁; 当一个事务为数据加上读锁之后，其他事务只能对该数据加读锁，而不能对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。共享锁的特性主要是为了支持并发的读取数据，读取数据的时候不支持修改，避免出现重复读的问题。

```sql
select xxx LOCK IN SHARE MODE
```

**排他锁(eXclusive Lock)**
排他锁又称写锁，简称X锁; 当一个事务为数据加上写锁时，其他请求将不能再为数据加任何锁，直到该锁释放之后,其他事务才能对数据进行加锁。排他锁的目的是在数据修改时候，不允许其他人同时修改，也不允许其他人读取。避兔了出现脏数据和脏读的问题。InnoDB会对**update\delete\insert** 语句自动添加排他锁。

```sql
SELECT xxx FOR UPDATE
```

**意向锁（IS，IX）**

如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是意向锁。

<img src="https://s2.loli.net/2022/07/09/zCrOxBt7RXMeqUs.png" alt="image-20220331002300641" style="zoom:50%;" />

锁的粒度：如下

### 记录锁（Record Lock）：

记录锁也属于行锁中的一种，只不过记录锁在加锁后锁住的只是表的某一条记录。精准条件命中，并且命中的条件字段是==唯一索引==，加了记录锁之后数据可以避免数据**在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。**

### 行锁：

锁住的是某一行或多行记录，加锁粒度小、资源开销大、InnoDB支持；会出现死锁；

1. 共享锁：
1. 排他锁：
1. 自增锁：通常是针对MySQL当中的自增字段。如果有事务回滚这种情况，数据会回滚，但是自增序列不会回滚。

#### 页锁

页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
特点:开销和加锁时间界于表锁和行锁之间，==会出现死锁==；锁定粒度界于表锁和行锁之间，并发度一般

#### 间隙锁(Gap Lock)

属于行锁中的一种，间隙锁是在事务加锁后其==锁住的是表记录的某一个区间==，当表的相邻ID之间出现空隙则会形成一个区间，遵循**左开右开**原则。
范围查询并且查询未命中记录，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。

#### 临建锁(Next-Key Lock)

也属于行锁的一种，并且它是==INNODB的行锁默认算法==，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住（相当于左开右闭区间）

```
(-∞, 10]//10, 11, 13, and 20，那么就需要锁定以下区间：
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

MVCC+Next Key Lock解决幻读问题

### 表锁

粒度大，加锁简单，容易冲突，InnoDB和MYISAM支持;

**意向锁；**

### 全局锁：

Flush tables with red lock，加锁后整个数据库实例处于只读状态，所有的数据变更操作都会被挂起。一般用于全局备份的时候。 

### 封锁协议：

#### 三级封锁协议：

##### 一级封锁协议：

事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。

可以解决==丢失修改==问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

<img src="https://s2.loli.net/2022/07/09/u7VdH5T8yreY13R.png" alt="image-20220331002633609" style="zoom: 50%;" />

##### 二级封锁协议

在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。

可以解决==读脏数据==问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。

<img src="https://s2.loli.net/2022/07/09/ZwhxUNldF2iz7sJ.png" alt="image-20220331002722085" style="zoom:50%;" />

##### 三级封锁协议

在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。

可以解决==不可重复读==的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。

<img src="https://s2.loli.net/2022/07/09/ha8Afx9kJTCeUir.png" alt="image-20220331002815849" style="zoom:50%;" />

### 两段锁协议

==加锁和解锁分为两个阶段进行。==可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。事务遵循两段锁协议是保证可串行化调度的充分条件。

### 隔离级别：

**未提交读（READ UNCOMMITTED）**

事务中的修改，即使没有提交，对其它事务也是可见的。

**提交读（READ COMMITTED）**

一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

**可重复读（REPEATABLE READ）**

保证在同一个事务中多次读取同一数据的结果是一样的。

**可串行化（SERIALIZABLE）**

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。

<img src="https://s2.loli.net/2022/07/09/4nQYOU9evzakf1g.png" alt="image-20220331003041948" style="zoom:50%;" />

## 多版本并发控制

多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和==可重复读==这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

### 基本思想

 MVCC 利用了多版本的思想，==写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系==。

在 MVCC 中事务的修改操作==（DELETE、INSERT、UPDATE）==会为数据行新增一个版本快照。

脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，**为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。**

### 版本号

- 系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
- 事务版本号 TRX_ID ：事务开始时的系统版本号。

### Undo 日志

MVCC 的多版本指的是多个版本的快照，快照存储在 ==Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。==

例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。

```sql
INSERT INTO t(id, x) VALUES(1, "a");
UPDATE t SET x="b" WHERE id=1;
UPDATE t SET x="c" WHERE id=1;
```

因为没有使用 `START TRANSACTION` 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。

<img src="https://s2.loli.net/2022/07/09/TOtoWZJsVgQkh1M.png" alt="image-20220331003420944" style="zoom: 67%;" />

INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。

### ReadView

MVCC 维护了一个 ReadView 结构，主要包含了当前系统==未提交==的事务列表 `TRX_IDs {TRX_ID_1, TRX_ID_2, ...}`，还有该列表的最小值 `TRX_ID_MIN` 和 `TRX_ID_MAX`。

<img src="https://s2.loli.net/2022/07/09/lK98rdtCAMjpHvw.png" alt="image-20220331003617091" style="zoom:50%;" />

在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。

#### 快照读与当前读

##### 1. 快照读

MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。

```sql
SELECT * FROM table ...;
```

##### 2. 当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。

```sql
INSERT;
UPDATE;
DELETE;
```

在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。

```sql
SELECT * FROM table WHERE ? lock in share mode;
SELECT * FROM table WHERE ? for update;
```



## 数据库的故障类型及其影响：

<img src="https://s2.loli.net/2022/07/09/WOzmAvn6p7HTRYr.png" alt="image-20220227104321711" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/07/09/P2oHYITcvXVhkLq.png" alt="image-20220227104553160" style="zoom:50%;" />

宏观思路：

1.事务故障

<img src="https://s2.loli.net/2022/07/09/cSNsfRr8OFgpjWu.png" alt="image-20220227104718319" style="zoom:50%;" />

2.系统故障

<img src="https://s2.loli.net/2022/07/09/5VMPn3uq6aJUe8L.png" alt="image-20220227104849795" style="zoom:50%;" />

检查点：

<img src="https://s2.loli.net/2022/07/09/wDbivs5QzAkY3Gd.png" alt="image-20220227110307101" style="zoom:50%;" />

介质故障：

<img src="https://s2.loli.net/2022/07/09/hybsqL3eXUFQ6Cm.png" alt="image-20220227110457099" style="zoom:50%;" />

转储点：

<img src="https://s2.loli.net/2022/07/09/LTOsZej5i2Hux89.png" alt="image-20220227110638415" style="zoom:50%;" />

> 事务故障：撤销+重做
>
> 系统故障：检查点+运行日志
>
> 介质故障：转储点+备份

### 日志：

<img src="https://s2.loli.net/2022/07/09/QwBvl8EW5JRjAYc.png" alt="image-20220227111000630" style="zoom:50%;" />

缓冲区处理策略：

<img src="https://s2.loli.net/2022/07/09/Whb8ELxrye34if6.png" alt="image-20220227111308524" style="zoom:50%;" />

<最常用：steal+no force>

<img src="https://s2.loli.net/2022/07/09/dWPeEatuIlzCMKb.png" alt="image-20220227111620920" style="zoom: 50%;" />

如果故障发生在output(A)和output(B)之间；

<img src="https://s2.loli.net/2022/07/09/Fpd87qIiDJBZARv.png" alt="image-20220227111834717" style="zoom: 50%;" />

日志的恢复策略：

<img src="https://s2.loli.net/2022/07/09/7azC83RyQt54esY.png" alt="image-20220227112136652" style="zoom:50%;" />

Undo 型日志：

<img src="https://s2.loli.net/2022/07/09/rbe4XZ265lYWEuL.png" alt="image-20220227112345906" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/eFTWjqgVtZDQhH8.png" alt="image-20220227112620312" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/qQkzn6jHmI13Lfy.png" alt="image-20220227112708676" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/BZnja8eCi4dyWT9.png" alt="image-20220227114556590" style="zoom:50%;" />

静止性检查点：

<img src="https://s2.loli.net/2022/07/09/NqoTKQBXAU5tSfg.png" alt="image-20220227114642973" style="zoom:50%;" />

非静止型检查点：

<img src="https://s2.loli.net/2022/07/09/pn9SwKi57NcFMhb.png" alt="image-20220227114712381" style="zoom:50%;" />

Redo型日志：

<img src="https://s2.loli.net/2022/07/09/QfbpeYTVs4rjdXu.png" alt="image-20220227114824465" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/c9zLM5RJCPWNA4I.png" alt="image-20220227114904786" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/fI7csOThPGxBWCl.png" alt="image-20220227115045733" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/yFgw16j3QaRpmSB.png" alt="image-20220227115351399" style="zoom:50%;" />

Undo/Redo 结合性日志：

<img src="https://s2.loli.net/2022/07/09/oRBvcj5dKgYaUSi.png" alt="image-20220227115551331" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/i9cyMC5pYDmfFBA.png" alt="image-20220227115642529" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/eAF8lswzv4IPx3B.png" alt="image-20220227115705082" style="zoom:50%;" />

<img src="https://s2.loli.net/2022/07/09/6A8kaBShXVROdwf.png" alt="image-20220227115832000" style="zoom: 50%;" />

<img src="https://s2.loli.net/2022/07/09/GOupHBsaX72K1Tq.png" alt="image-20220227115923570" style="zoom:50%;" />

MySQL：

数据存储引擎：Engine

| InnoDB                                                | MyISAM                           |
| ----------------------------------------------------- | -------------------------------- |
| 每个表有两个文件，MYD（数据文件）和MYISAM（索引文件） | 索引数据在一起，只有一个.idb文件 |
| 非聚簇索引                                            | 聚簇索引                         |
| 行级锁                                                | 表级锁                           |
| 支持ACID的事务及四种隔离级别                          | 不支持事务，但每次查询都是原子的 |
| 外键约束                                              |                                  |

## 集群：

是一种后端数据库的部署方式。

集群的好处：

- 高可用性：故障检测及迁移，多节点备份。
- 可伸缩性：新增数据库节点便利，方便扩容。
- 负载均衡：切换某服务访问某节点，分摊单个节点的数据库压力。

集群要考虑的风险：

- 网络分裂：群集还可能由于网络故障而拆分为多个部分，每部分内的节点相互连接，但各部分之间的节点失去连接。
- 脑裂：导致数据库节点彼此独立运行的集群故障称为“脑裂”。这种情况可能导致数据不一致，并且无法修复，例如当两个数据库节点独立更新同一表上的同一行时

### MYSQL Cluster：

MySQL 官方集群部署方案：[（多种）](https://www.cnblogs.com/lgx211/p/12456859.html#3mysql-cluster)

MySQL Replication：主从复制是通过==重放binlog==实现主库数据的异步复制。master对数据的写操作记入二进制日志文件中(binlog)，生成一个 log dump 线程，用来给slave库的 i/o线程传binlog。slave库的i/o线程将得到的binlog日志写到中继日志（relaylog）中，slave库的sql线程，会读取relaylog文件中的日志，并解析成具体操作，通过主从的操作一致，而达到最终数据一致。

<img src="https://s2.loli.net/2022/07/09/MHymtBYhNoJLnje.jpg" alt="MySQL Replication_lgx211" style="zoom:80%;" />

一主多从的结构，主要目的是实现数据的多点备份（没有故障自动转移和负载均衡）。相比于单个的mysql，一主多从下的优势如下：

- 如果让后台读操作连接从数据库，让写操作连接主数据库，能起到读写分离的作用，这个时候多个从数据库可以做负载均衡。
- 可以在某个从数据库中暂时中断复制进程，来备份数据，从而不影响主数据的对外服务（如果在master上执行backup，需要让master处于readonly状态，这也意味这所有的write请求需要阻塞）。

MYSQL的主从集群只会将Binary log从主节点同步到从节点，而不会反过来同步。由此也就引申出了==读写分离==问题：写的操作只能在主节点完成，读的操作可以在主或从中完成；**读写分离是在使用主从集群的基础上，业务逻辑自己实现的功能。**

场景：因为数据库操作总是读多写少，而且改方案可以保证主节点挂了从节点顶上来；

<img src="https://s2.loli.net/2022/07/09/LrFjgKHmwkP3cXb.png" alt="image-20220327151020756" style="zoom:80%;" />

由于Binary log可能会传送丢失，因此要返回一个ack保证其顺利传输；

# 慢查询日志

MySQL的慢查询日志是MySQL提供的一种日志记录，**它用来记录在MySQL中响应时间超过阀值的语句**，具体指运行时间超过**long_query_time**值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句

### 优化：

- 分析语句，是否load了不要的数据(数据库会自动优化语句，不需要分析语句吧？)
- 分析语句的执行情况，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能地命中索引；
- 如果对语句的优化以及无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或纵向的分表；

# 题目：

数据库并发操作带来的影响可能有：

各种并发一致性问题







