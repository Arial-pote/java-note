# 多线程：

并发与并行的区别：

**并发同一时段内宏观上有多程序运行**——实际上是通过时间片的分割实现；

**并行时同一时刻有多个任务被执行**，通过多个cpu同时处理不同的进程；(只出现在多处理器系统上)

### 新建线程的方法：

#### 1.继承Thread：

使用方法：编写一个类myThread继承Thread并重写run函数，在主线程`myThread t = new myThread();` `t.start();`
不建议使用，避免OOP单继承局限性；

#### 2.实现Runnable接口：

使用方法：编写一个类myThread实现Runnable接口并重写run函数，在主线程 `Thread t = new Thread(myThread);` `t.start();`
避免单继承局限性，灵活方便，方便一个对象被多个线程使用；

#### 3.实现Callable接口：

使用方法：编写一个类myThread实现Callable接口并重写call函数，需要返回值类型，常与Futuer连用；在主线程：

```java
ExecutorService ser = Executors.newFixedThreadPool(1);
Future<Boolean> result = ser.submit(t1);
Boolean r1 = result.get();
ser.shutdownNow();
```

### 线程状态：

调用`Thread.State.xx;`

1. NEW：尚未启动的线程；
1. RUNNABLE：在java虚拟机中运行的线程；
1. BLOCKED：被阻塞等待监视器锁``定的线程；
1. WAITING、TIMED_WAITING；
   1. 正在等待另一个线程执行特定动作线程；
   1. 正在等待另一个线程执行动作达到指定等待时间的线程；
1. TERMINATED：已退出的线程；

### 线程操作：

1. 线程停止：不建议使用Thread自带的函数，如stop之类的，自己编写一个stop使用标志位
1. 线程休眠：使用函数sleep。作用：模拟网络延时，检测线程不安全。
1. 线程礼让：yield函数，让当前线程回到就绪状态，暂停但不阻塞，cpu重新选一个ready状态的线程（可能还是当前线程）；
1. 线程合并（插队）：join函数，待此线程执行完后再执行其他线程，其他线程阻塞；（在`bThread`运行过程中，`aThread.join();`，此时b线程只能等a线程运行完才能执行）
1. 线程优先级：`thread.setPriority();`数字表示优先级，范围1-10，优先级高不一定管用；

#### 守护线程daemon：

`thread.setDaemon();`

线程分为用户线程和守护线程，虚拟机必须确保用户线程（main）执行完毕，但不用等待守护线程，如垃圾回收（gc）、后台操作日志、监控内训。

#### lambda表达式：

使用场景：避免过多的匿名内部类（没有类的名称，必须借助接口或父类），使代码变得简洁

函数式接口：

定义：任何接口，如果它只包含唯一一个抽象方法（有多个的话lambda不知道对应哪一个），那么它就是一个函数接口。对于函数式接口，我们可以通过lambda表达式来创建该接口；

```java
//匿名内部类
new Thread(new Runnable(){// 接口名
	@Override
	public void run(){// 方法名
		System.out.println("Thread run()");
	}
}).start();
//lambda表达式
new Thread(
		() -> System.out.println("Thread run()")// 省略接口名和方法名
).start();//变量可以省略类型
```

## 线程同步：

发生在同一个对象被多个线程操作（并发）；

场景：抢票、两个银行同时取钱、多个线程同时向List里添加东西；

队列+锁（synchronized）能保证线程的安全性，

缺点：

1. 一个线程持有锁会导致其他所有需要此锁的线程挂起；
1. 在多线程竞争下，加锁、释放锁会导致比较多的==上下文切换和调度延时==，引起性能问题；
1. 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题；

### 同步方法：

[JAVA锁机制-可重入锁,可中断锁，公平锁，读写锁，自旋锁, - aspirant - 博客园 (cnblogs.com)](https://www.cnblogs.com/aspirant/p/6930436.html)

#### 1.synchronized锁：

由于我们通过==private关键字==来保证数据对象只能被方法访问，因此只需要针对方法提出一套机制，即synchronized关键字，它包括两种用法：**synchronized方法 **和 **synchronized块**；

```java
public synchronized void method(int obj){};
synchronized(obj){
    ...
}
```

synchronized方法控制对对象的访问，每个对象对应一把锁，每个调用该对象的方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞；obj称为==同步监视器（Monitor）==，obj可以是任何对象，但是推荐使共享资源作为同步监视器；但如果是==同步方法==，则无需指定同步监视器，因为同步监视器的同步方法就是对象本身或者是class；

synchronized是非公平锁；

##### 原理：

[深入分析Synchronized原理(阿里面试题) - aspirant - 博客园 (cnblogs.com)](https://www.cnblogs.com/aspirant/p/11470858.html)

synchronized锁在软件层面依赖jvm，==Synchronized用的锁就是存在Java对象头里==，

> **1. synchronized块：**
>
> 语义底层是通过一个`monitor`的对象来完成（`wait`/`notify`等方法也依赖于monitor对象），通过反编译可以看到`monitorenter`和`monitorexit`指令：
>
> ​	1.1_ `monitorenter`：
>
> ​		1.如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；
>
> ​		2.如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1；
>
> ​		3.如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权；
>
> ​	1.2_ `monitorexit`：
>
> ​		1.指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。
>
> **2.synchronized方法：**
>
> ​		没有通过指令 `monitorenter` 和 `monitorexit` 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了 `ACC_SYNCHRONIZED` 标示符。当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。**在方法执行期间，其他任何线程都无法再获得同一个monitor对象。**

在线程进入同步代码块的时候，如果此同步对象没有被锁定，即它的锁标志位是01，则虚拟机首先在当前线程的栈中创建我们称之为<u>==锁记录（Lock Record）==的空间，用于存储锁对象的Mark Word的拷贝</u>，官方把这个拷贝称为Displaced Mark Word。整个Mark Word及其拷贝至关重要。

每一个被锁住的对象Mark Word都会和一个Lock Record关联（对象头的MarkWord中的Lock Word指向Lock Record的起始地址），同时Lock Record中有一个**Owner字段存放拥有该锁的线程的唯一标识（或者`object mark word`），表示该锁被这个线程占用。**

------

从JDK6开始，就对synchronized的实现机制进行了较大调整，将锁分为了四种状态：**无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态**：

:question: **synchronized锁升级：偏向锁 → 轻量级锁 → 重量级锁：**

初次执行到synchronized代码块的时候，锁对象变成**偏向锁**（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并**不会主动释放偏向锁**。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。**由于之前没有释放锁，这里也就不需要重新加锁。**如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。

一旦有第二个线程加入**锁竞争**，偏向锁就升级为**轻量级锁（自旋锁）**。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。

在轻量级锁状态下继续锁竞争，没有抢到锁的线程将**自旋**，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先**比较**当前锁标志位是否为“释放”，如果是则将其**设置**为“锁定”，比较并设置是**原子性**发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。

* 线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活。**如果线程A仍然存活，**将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是**如果判断结果是线程A不存在了**，则线程B持有此偏向锁，锁不升级。

**重量级锁：**

Synchronized是通过对象内部的一个叫做 监视器锁（Monitor）来实现的。但是监视器锁本质又是==依赖于底层的操作系统的Mutex Lock==来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为 “重量级锁”。

![img](https://s2.loli.net/2022/07/09/9q7ZmRQbV4lrCS2.png)

如果当前对象持有轻量锁，但有多个线程在申请锁时，会因为多个线程自旋消耗CPU，此时升级为重量锁较为合适；

------

==如何保证变量的内存可见性，原子性：==

可见性：

当一个线程进入 synchronizer 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。

原子性：

保证代码块内执行的原子性。

------

**不需要synchronized的操作——JVM规范定义的几种原子操作：**

1. ==基本类型==（long和double除外）赋值，例如：`int n = m`；【long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。】
1. ==引用类型赋值==，例如：`List<String> list = anotherList。`

但是，如果是多行赋值语句，就必须保证是同步操作，例如：

```java
class Pair {
    int first;
    int last;
    public void set(int first, int last) {
        synchronized(this) {
            this.first = first;
            this.last = last;
        }}}
```

有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：

```java
//多行赋值语句转为数组变量赋值
class Pair {
    int[] pair;
    public void set(int first, int last) {
        int[] ps = new int[] { first, last };
        this.pair = ps;
    }}
```

如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的Counter类就是线程安全的。Java标准库的java.lang.StringBuffer也是线程安全的。

**还有一些不变类**，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。

最后，类似**Math这些只提供静态方法**，没有成员变量的类，也是线程安全的。

除了上述几种少数情况，大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。

#### 2.Lock锁：

ReentrantLock实现lock接口：

`AbstractQueuedSynchronizer `简称AQS，是一个用于构建锁和同步容器的框架。`ReentrantLock`的`Sync`是AQS的子类：

AQS使用一个==FIFO的队列==表示排队等待锁的线程，它维护一个**status的变量**，**每个节点维护一个waitStatus的变量**，当线程获取到锁的时候，队列的status置为1；队列头部的线程执行完毕之后，它会调用它的后继的线程。

> waitStatus含义：
>
> 0：节点初始化默认值或节点已释放锁；
>
> 1：CANCELLED，表当前节点获取锁的请求已经被取消了；
>
> -1：SIGNAL，表示当前节点的后续节点需要被唤醒；
>
> -2：CONDITION，当前节点正在等待一个Condition对象；

**AQS中还有一个表示状态的字段state，例如ReentrantLocky用它表示线程重入锁的次数**，Semaphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。

==ReentrantLock==类实现了Lock，它拥有比synchronized相同的并发性和内存语义，内部三个类，抽象类`Sync`，公平锁`FairSync`，非公平锁`NonfairSync`；

##### FairSync 公平锁：

与NonFairSync的区别在于在lock中直接调用acquire(1)，不会去尝试CAS获得锁；

##### NonFairSync 非公平锁：

在`lock()`函数的重写中，当前线程直接调用CompareAndSetState()函数尝试获取锁，并不限制只有队伍头部的节点才能获取锁，也就是所谓的插队；CAS不成功的话调用`acquire(1)`：

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&//会调用nonfairTryAcquire
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```

`nonfairTryAcquire()`检查state字段，若为0，表示锁未被占用，那么尝试占用，若不为0，检查当前锁是否被自己占用，若被自己占用，则更新state字段，表示重入锁的次数。如果以上两点都没有成功，则获取锁失败，返回false，然后用`addWaiter()`将当前线程封装为Node并加入队列。

> `addWaiter()`中加入尾结点部分也有考虑多线程，先用CAS操作修改了尾节点后，然后再将前节点与当前尾节点相连；
>
> CAS操作不成功或当前队列为空，进入`enq(node)`函数，进行自旋+CAS入队操作（同时自旋的for循环中有一个判空初始化的操作）；

然后执行`acquireQueued()`函数自旋判断当前node是否是第一个，是的话执行；

```java
/**
 * 已经入队的线程尝试获取锁
 */
final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true; //标记是否成功获取锁
    try {
        boolean interrupted = false; //标记线程是否被中断过
        for (;;) {
            final Node p = node.predecessor(); //获取前驱节点
            //如果前驱是head,即该结点已成老二，那么便有资格去尝试获取锁
            if (p == head && tryAcquire(arg)) {
                setHead(node); // 获取成功,将当前节点设置为head节点
                p.next = null; // 原head节点出队,在某个时间点被GC回收
                failed = false; //获取成功
                return interrupted; //返回是否被中断过
            }
            // 判断获取失败后是否可以挂起,若可以则挂起
            if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                // 线程若被中断,设置interrupted为true
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
```

**线程入队后能够挂起的前提是，它的前驱节点的状态为SIGNAL，如果不符合，再看前驱节点是否>0(CANCELLED)，若是那么向前遍历直到找到第一个符合要求的前驱，<u>若不是则将前驱节点的状态设置为SIGNAL</u>。**

`unlock()`函数调用`release()`函数释放锁，流程大致为先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，如果释放失败那么返回false表示解锁失败。**这里我们也发现了，每次都只唤起头结点的下一个节点关联的线程**。

![img](https://s2.loli.net/2022/07/09/LD495bnMIhC1PFv.jpg)

##### 超时机制：

……

##### 线程间通信：

指运用Condition通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。

------

实际运用：

采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。

```java
try{
//处理任务
}catch(Exception ex){
}finally{
lock.unlock(); //释放锁
}
```

#### 3.volatile关键字：

volatile的作用：

1. 保证变量内存的可见性（不保证原子性）；
1. 禁止指令重排序；

:a: 可见性如何保证：

使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 **CPU 总线嗅探机制**告知其他线程该变量副本已经失效，需要重新从主内存中读取。

> 总线嗅探机制：
>
> 由于CPU的速度远大于硬盘读取数据的速度，我们使用多级缓存来解决了 CPU 运算速度和内存读取速度不一致问题。但由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而**嗅探是实现缓存一致性的常见机制**。
>
> <img src="https://s2.loli.net/2022/07/09/XvFcpy6duwAnKLG.jpg" alt="img" style="zoom:67%;" />
>
> **嗅探机制工作原理**：每个处理器通过==监听==在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会**将当前处理器的缓存行设置无效状态**，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。
>
> > 注意：基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。

:a:原子性为何不能保证：

volatile只能保证对于其修饰的变量，单纯的赋值操作是原子性的。其能够使用的场景必须满足：

1. 对变量的写入不依赖当前值，`number++`
1. 该变量没有包含在具有其他变量的不变式中，`low<up`

------

:a:如何禁止指令重排序（原理）：

重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化。有三种类型：<u>编译器优化的重排序（编译器优化）、指令级并行重排序（处理器优化）、内存系统的重排序（处理器优化）。</u>

##### 内存屏障指令：

为了使volatile实现**可见性**，JMM 会限制特定类型的编译器和处理器重排序。为此，JMM 针对编译器制定了 ==volatile 重排序规则表==，如下所示：

![img](https://s2.loli.net/2022/07/09/NdwLOoytVKZ6kaX.jpg)

使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入==内存屏障指令==（一组处理器指令）来禁止特定类型的处理器重排序，如下所示：

![img](https://s2.loli.net/2022/07/09/rq6dcy9Dh3UJ2jF.jpg)

> StoreLoad 屏障是一个全能型的屏障，它同时具有其他三个屏障的效果。所以执行该屏障开销会很大，因为它使处理器要把缓存中的数据全部刷新到内存中。

具体操作：

![img](https://s2.loli.net/2022/07/09/VKZN5I6hu9TeqlM.jpg)

从上图，我们可以知道 volatile 读 / 写插入内存屏障规则：

- 在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。
- 在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。

也就是说，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。

##### happens-before 概述：

操作之间的==内存可见性==。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。

------

**synchronized和volatile异同：**

- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程；
- 从内存可见性角度，volatile读相当于加锁，volatile写相当于解锁；
- synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。

## 线程通信：

应用场景：生产者、消费者问题；synchronized只能解决线程间的同步，但没有办法让线程间通信。而java提供了几个方法解决线程间的通信问题：	

- `wait`：线程一直等待直到接收通知，与sleep不同，wait会释放锁；
- `wait(long timeout)`：指定等待的毫秒数；
- `notify()`：唤醒一个处于等待状态的线程；
- `notifyAll()`：按优先级唤醒同一个对象上所有调用wait()方法的线程

常用管程法，标志位法；

## 线程池：

线程的创建销毁过于浪费时间，因此采用线程池：

![image-20220709164655606](https://s2.loli.net/2022/07/09/i9n2olF83EN4Lk7.png)

　一个线程池包括以下四个基本组成部分：

1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括：创建线程池，销毁线程池，添加新任务；
1. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
1. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；
1. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。

线程池技术正是关注如何**缩短或调整线程的创建、销毁的时间**的技术，从而提高服务器程序性能的。它把这些时间分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有线程的创建、销毁的开销了。

`java.uilt.concurrent.ThreadPoolExecutor`类是线程池中最核心的一个类，他有四个构造函数，最主要的是：

```java
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory, RejectedExecutionHandler handler);
```

- **corePoolSize：**核心池的大小。在创建了线程池后，默认情况下，线程池中并没有任何线程，而是等待有任务到来才创建线程去执行任务，除非调用了`prestartAllCoreThreads()`或者`prestartCoreThread()`方法，是预创建线程的意思，即在没有任务到来之前就创建corePoolSize个线程或者一个线程。**默认情况下**，在创建了线程池后，线程池中的线程数为**0**，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中；
- **maximumPoolSize：**线程池最大线程数，它表示在线程池中最多能创建多少个线程；
- **keepAliveTime**：表示线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池中的线程数不大于corePoolSize：**即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize**；
  但是如果调用了`allowCoreThreadTimeOut(boolean)`方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；
- **unit：**参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性，以及**TimeUtil的源码展示**：

```java
TimeUnit.DAYS;               //天
TimeUnit.HOURS;             //小时
TimeUnit.MINUTES;           //分钟
TimeUnit.SECONDS;           //秒
TimeUnit.MILLISECONDS;      //毫秒
TimeUnit.MICROSECONDS;      //微妙
TimeUnit.NANOSECONDS;       //纳秒
```

------

- **workQueue**：一个阻塞队列，用来存储等待执行的任务，这个参数的选择会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择：

1. `ArrayBlockingQueue`：

1. `LinkedBlockingQueue`：一般可以认为是无界队列，FixedThreadPool和SingleThreadPool线程数是固定的，所以没有办法增加特别多的线程来处理任务，这时就需要 LinkedBlockingQueue 这样一个没有容量限制的阻塞队列来存放任务。

1. `SynchronousQueue`：对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer.MAX_VALUE，可以理解为线程数是可以无限扩展的。

1. `DelayedWorkQueue`：对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以==延迟执行任务==，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。

   DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会**按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构（堆的应用之一就是 优先级队列）**。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。

------

- **threadFactory**：线程工厂，主要用来创建线程；

- **handler**：表示当==拒绝处理任务时的策略==，有以下四种取值：

```java
ThreadPoolExecutor.AbortPolicy;//丢弃任务并抛出RejectedExecutionException异常。 
ThreadPoolExecutor.DiscardPolicy;//也是丢弃任务，但是不抛出异常。 
ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy;//由调用线程处理该任务 
```

> - **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
> - **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。
>
> **如何判断是 CPU 密集任务还是 IO 密集任务？**
>
> CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上

Future

定义：Future是java1.5版本引入的一个interface，可以方便的用于异步结果的获取；

运用场景：执行一个长时间任务时，使用Future可以让我们暂时去处理其他任务，等长任务执行完毕再返回其他结果；

# java基础

`hashCode()`: 定义在JDK的`Object`类中，意味着所有对象都具有hashCode()函数，而部分对象可能会重写本函数；在HashSet和HashMap里面，判断对象首先通过判断对象的hashCode是否相等，相等的话调用equals判断；

重写`equals()`需要重写`hashCode()`函数，否则可能会导致equals函数判断两个是相等的，hashCode判断两个函数不等，此时使用HashSet/HashMap就失去了判等功能；

> `Object `的`equals`函数作用是比较地址：判断两个Object地址是否相等；

### 基本类型及其包装类：

Short、Integer、Long、Character、Boolean 6 个包装类都是实现了常量池技术的，而Float、Double没有；

自动装箱与拆箱：装箱是利用函数`ValueOf()`将基本类型封装到包装类里，拆箱则是利用`xxxValue() `例如Integer类就会调用intValue；==所有的整形包装类都要用equals函数做比较==，例如下文代码返回false -> 因为从常量池取出的地址和new出的新对象地址不同；

```java
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);
```

#### String：

String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
	//String类使用final保存关键字
}
```

>  我们知道被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，`final` 关键字修饰的数组保存字符串并不是 `String` 不可变的根本原因，因为这个数组保存的字符串是可变的（`final` 修饰引用类型变量的情况）。
>
>  `String` 真正不可变有下面几点原因：
>
>  1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
>  1. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。
>
>  补充：在 Java 9 之后，`String` 、`StringBuilder` 与 `StringBuffer` 的实现改用 byte 数组存储字符串。
>
>  `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 `AbstractStringBuilder` 类还提供了很多修改字符串的方法比如 `append` 方法。

##### 线程安全性：

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
1. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
1. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

**字符串拼接用 “+” 还是 StringBuilder?**

Java 语言本身<u>并不支持</u>运算符重载，“+”和“+=”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的元素符。对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：**编译器不会创建单个 `StringBuilder` 以复用，会导致创建过多的 `StringBuilder` 对象**。

##### 字符串常量池：

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了==避免字符串的重复创建==。

```java
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa==bb);// true
```

JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。

```java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";//常量池中的对象
String str4 = str1 + str2; //在堆上创建的新的对象
String str5 = "string";//常量池中的对象
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

对于==编译期可以确定值的字符串==，也就是常量字符串 ，jvm 会将其存入字符串常量池。因此，`str1` 、 `str2` 、 `str3` 都属于字符串常量池中的对象。并且对于 `String str3 = "str" + "ing"` 编译器会给你优化成 `String str3 = "string"`；引用的值在程序编译期是无法确定的，编译器无法对其进行优化。

对象引用和 “+” 的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 （`调用了 new String();`）。

不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。

```java
final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
```

### 封装、继承、多态：

面向对象的三大特点：

多态：表示一个对象具有多种对象，具体表现为==父类的引用指向子类的实例==；

特点：

1. 对象类型和引用类型之间有 继承类/实现接口 的关系；
1. 引用类型变量发出的调用到底是哪个类中的方法，只有运行时才能确定；
1. 多态不能调用“只在子类中存在但在父类中不存在的方法”；
1. 如果子类重写了父类的方法，真正执行的是子类的覆盖方法，如果子类没有覆盖父类的方法，执行的是父类的方法；

:question: 抽象类和接口类：

```java
public abstract class chouxiang{ //抽象类
    public abstract void func1(){} //抽象方法
    public default void func2(){} //默认方法
}
public interface jiekou{
}
```

共同点：

- 都不能被实例化。
- 都可以包含抽象方法。抽象方法的实现由子类定义；
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键在接口中定义默认方法）。

区别：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

### 浅拷贝与深拷贝：

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果==原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址==，也就是说拷贝对象和原对象共用同一个内部对象。

  > java的Integer、String类是特例，浅拷贝后修改原对象的String类不会导致克隆对象的String类也改变。因为String，Integer是线程安全的**不可变类（Immutable Class）**，每一次赋值，指向的都是堆上的一个新的对象。

- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

- **引用拷贝**：引用拷贝就是两个不同的引用指向同一个对象。

拷贝需要实现 `Cloneable` 接口，并重写了 `clone()` 方法。

<img src="https://s2.loli.net/2022/07/09/rT91lhobZawIFXt.png" alt="image-20220319132015999" style="zoom: 50%;" />

如何实现深拷贝：

1.简单粗暴的将在clone函数中逐个调用其内部对象的clone函数，但这样层级嵌套很复杂&麻烦（要保证其内部对象的clone也是深拷贝），因此建议使用==反序列化==的方式进行拷贝：

```java
public class Student implements Serializable {
    private String name;
    private int age;
    private Major major;

    public Student clone() {
        try {
            //将对象本身序列化到字节流；
            ByteArrayOutputStream b = new ByteArrayOutputStream();
            ObjectOutputStream o = new ObjectOutputStream(b);
            o.writeObject(this);
            //再将字节流通过反序列化的方式得到副本；
            ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(b.toByteArray()));
            return (Student) objectInputStream.readObject();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}
```

## 泛型：

在Java 1.5 版本引入；泛型的好处：提供了编译时类型安全检测机制、消除了强制类型的转换。它的使用场景有：

- 可用于定义通用返回结果 `CommonResult<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 用于构建集合工具类。参考 `Collections` 中的 `sort`, `binarySearch` 方法

### 泛型类：

**泛型类在创建对象的时候，指定操作的具体的数据类型**，使代码复用性增强。如果创建泛型类时没有指定类型，则按照`Object`来接收。不支持基本的数据类型（因为基本数据类型不继承于Object）。==泛型类根据不同数据类型创建的对象，本质上是同一类型。==（class相同）

```java
class Generic<K>{//K是泛型标识——类型实参
	private K key;
	public K getKey(){}
	public void setKey(K key){}
}
```

从泛型类派生子类：

1. 子类也是泛型类 -> 子类父类的泛型类型至少有一个要一致；

   ```java
   class ChildGeneric<T> extends Generic<T>{}
   class ChildGeneric<T,K,E> extends Generic<T>{}
   ```

1. 子类不是泛型类 -> 父类要明确泛型的数据类型；

   ```java
   class ChildGeneric extends Generic<String>{}
   ```

### 泛型接口：

```java
interface Generator<K>{
    T getKey(){}
}
```

泛型接口的使用：

1. 实现类也是泛型类 -> 实现类和父类的泛型类型至少有一个要一致；

   ```java
   class ChildGeneric<T> implements Generator<T>{}
   class ChildGeneric<T,K,E> implements Generator<T>{}
   ```

1. 实现类不是泛型类 -> 接口要明确泛型的数据类型；

   ```java
   class ChildGeneric implements Generator<String>{}
   ```

### 泛型方法：

只有声明了`<T>`的方法才是泛型方法，==泛型类中使用的泛型的成员变量不是泛型方法==；泛型类中使用泛型的成员函数，其具体类型是在创建对象时确定的；**而泛型方法是在调用方法时确定的**；泛型方法不一定要在泛型类中

```java
class productGetter<K>{
    public <E> E getProduct(ArrayList<E> arr){
		return list.get(random.nextInt(arr.size()));
	}
}
//调用
String product = productGetter.getProduct(new ArrayList<String>("s"));
```

> 1. 即使在泛型类和泛型函数中的泛型用同一个标识符声明，e.g(将上文中的`<K>、<E>`统一)，但泛型函数不会收到影响；
>
> 1. 泛型类的成员函数如果声明为`static`，则不能使用泛型；但泛型函数可以；
>
> 1. 泛型函数支持可变参数
>
>    ```java
>     public <E> E getProduct(E... e){}
>    ```

### 类型通配符：

类型通配符一般是使用 `?` 代替具体的类型实参，==所以类型通配符是类型实参，而不是类型形参；==内部接收参数只能用`Object`；

```java
public static <T> void showBox(Box<T> arr) { }
public static void showBox(Box<?> arr) { 
	Object o = arr.getRandom();
    System.out.println(o);
}
//使用问号的是类型通配符，两种用相同的代码体能产生一样的效果
```

#### 类型通配符上限：

只能够使用Number及其子类作为传入数据类型，内部可用上限（父类）接收参数；

```java
public static void showBox(Box<? extends Number> arr){
    Number number = arr.getRandom();
}
```

> 注意在此处，函数中数组或集合不能填充元素，即出现` arr.add(new Integer(1));` 虽然`Integer`是`Number`的父类，但可能实际中传入的会是`Integer`的子类；

#### 类型通配符下限：

要求该泛型的类型，只能是实参类型，或实参的父类类型；

```java
public static void showBox(Box<? super Number> arr){
    Object o = arr.getRandom();
}
```

> 使用下限通配符，数组or集合可以填充元素，但不能保证其满足约束要求

### 类型擦除：

java的泛型是伪泛型，这是因为**在java运行期间，所有的泛型信息都会被擦除掉。**

无限制类型擦除：普通泛型

有限制类型擦除：对应有上限的泛型

泛型数组的创建：

- 可以声明带泛型的引用，但不能直接创建带泛型的数组对象；
- 可以通过`java.lang.reflect.Array`的 `newInstance(Class<T>,int) `函数创建`t[]`数组

## Exception:

**Exception 和 Error 有什么区别？**

在 Java 中，所有的异常都有一个共同的祖先 `java.lang` 包中的 `Throwable` 类。`Throwable` 类有两个重要的子类:

- **`Exception`** :程序本身可以处理的异常，可以通过 `catch` 来进行捕获。`Exception` 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。
- **`Error`** ：`Error` 属于程序无法处理的错误 ，我们~~没办法通过 `catch` 来进行捕获~~不建议通过`catch`捕获 。例如Java 虚拟机运行错误（`Virtual MachineError`）、虚拟机内存不够错误(`OutOfMemoryError`)、类定义错误（`NoClassDefFoundError`）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。

**Checked Exception 和 Unchecked Exception有什么区别：**

**Checked Exception** 即受检查异常，Java 代码在编译过程中，如果受检查异常没有被 `catch`/`throw` 处理的话，就没办法通过编译 。**Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都统称为非受检查异常

#### try-finally-catch：

- **`try`块：** 用于捕获异常。其后可接零个或多个 `catch` 块，如果没有 `catch` 块，则必须跟一个 `finally` 块。

- **`catch`块：** 用于处理 try 捕获到的异常。

- **`finally` 块：** 无论是否捕获或处理异常，`finally` 块里的语句都会被执行。当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。

  > **不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。
  >
  > finally 中的代码不一定会被执行。就比如说 `finally` 之前虚拟机被终止运行的话，finally 中的代码就不会被执行

------

## 序列化：

如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

- **序列化**： 将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

<img src="https://s2.loli.net/2022/07/09/7jEkBRhzG4CAg5e.png" alt="image-20220321103935895" style="zoom:67%;" />



对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

> - `transient` 只能修饰变量，不能修饰类和方法。
> - `transient` 修饰的==变量，在反序列化后变量值将会被置成类型的默认值==。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
> - `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。



## 数组：

1. 大小固定
1. 数组是一种==引用数据类型==，数组引用变量只是一个引用，数组元素在堆中和数组变量在栈中。引用类型在64位中的大小为8byte。

> 值类型（基本数据类型）存放在栈中；
>
> 引用类型：除了基本数据类型之外的所有类型（如class类型），栈中堆中都有空间；
>
> <img src="https://s2.loli.net/2022/07/09/DRW2yaupn6YP9we.png" alt="image-20210730134551524" style="zoom:50%;" />
>
> 值类型中：按值传递，a、b是创造出来的形参，方法调用完成后消失；
> 引用类型中：按引用传递，a、b是创造出来的形参，指向c、d所指向的空间；

## 集合类：

![image-20220321114019470](https://s2.loli.net/2022/07/09/y8SCaQV1G49fv5r.png)

存放8个基本数据类型时，需变为基本类型封装类 `int->Integer`

### Set集合

1. 对象无重复、**无排序**；
1. 对Set集合中成员的访问和操作是通过<u>对集合中对象的引用</u>进行的，所以Set集合不能有重复对象（包括Set的实现类）；
1. 判断集合中两个对象相同，不用` == `用 `equals() `

> == :
>
> 基本数据类型（也称原始数据类型） ：比较的是他们的值。
> 引用数据类型：比较的是他们在内存中的存放地址（确切的说，是**堆内存**地址）。
>
> equals() :
>
> 这个方法的初始默认行为是比较对象的==内存地址值(需重写)==，在一些类库当中这个方法被重写了，如String、Integer、Date。在这些类当中equals有其自身的实现（一般都是用来比较对象的成员变量值是否相同）。

#### * HashSet

`hashCode() : `获得散列值 （int

- 判断set中对象是否重复，避免逐一用equals()比较，hashMap在一个表中存储hashCode，先比较hashCode（散列值），无重复=>加入；==有重复=>先equals()比较，无重复则散列其他地址。==
- 使用成员对象来计算hashcode值

`HashSet`底层使用`HashMap`实现的，在其内部有成员变量 `map` 用于存储数据，以及PRESENT 用于当作所有k-v 对的value值。

```java
private transient HashMap<E,Object> map;
// Dummy value to associate with an Object in the backing Map
private static final Object PRESENT = new Object();
```

在调用`HashSet.add()`函数时，会调用`map.put(e,PRESENT)` 向map放入新的函数；该函数在计算了hash值之后调用`putVal()`函数。

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}//后续详见HashMap部分
```

#### LinkedHashSet

1. 最大的特点就是有排序（以元素添加的顺序）；
1. 类似于HashSet底层是使用HashMap实现的，LinkedHashSet也是调用LinkedHashMap；

#### TreeSet

1. TreeSet采用红黑树的数据结构来存储集合元素；有序无重复。

> 排序方式：
>
> - 自然排序：调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序。如果试图把一个对象添加到TreeSet时，则该==对象的类必须实现Comparable接口==，否则程序会抛出异常。
> - 定制排序：通过Comparator接口里的==a.compareTo(b)==方法，该方法用于比较大小。返回“负数”，意味着“a比b小”；返回“零”，意味着“a等于b”；返回“正数”，意味着“a大于b”。

#### 小结：

1. HashSet的性能比TreeSet好(包括添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。
   当需要一个始终保持排序的Set时，才使用TreeSet，否则使用HashSet。
1. 对于LinkedHashSet，普通的插入、删除操作比HashSet要略慢一点，因为维护链表会带来的一定的开销。好处是，遍历比HashSet会更快
1. HashSet、TreeSet都是线程不安全的，可以通过Collections工具类的synchronizedSortedSet方法来"包装"该Set集合。`SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));`

------

### List集合

1. 集合中的对象按照索引的顺序排序，可以有重复的对象。List与数组相似。
1. List以线型方式存储，默认按元素的添加顺序设置元素的索引。

#### LinkedList：

底层是双向链表结构，拥有静态内部类`Node{E item, E prev, E next}`。常被当作双端队列使用（Queue、Stack）.基本属性有：

```java
transient int size = 0;     //LinkedList中存放的元素个数
transient Node<E> first;    //头节点
transient Node<E> last;     //尾节点
```

其中在LinkedList的头、尾插入数据都是靠头节点和尾节点；

而一些通过下标访问、插入、删除则是通过函数Node node(index){} 返回对应的Node节点，再进行操作；

| Vector                                                       | ArrayList                                           | LinkedList                                          |
| ------------------------------------------------------------ | --------------------------------------------------- | --------------------------------------------------- |
| 同步的，可以用在==多线程==的情况                             | 非同步                                              | 非同步                                              |
| 访问快速、插入&删除慢，但由于所有函数都被synchronized修饰，所以慢 | 访问快速、插入&删除慢                               | 随机访问效率比ArrayList要低，顺序访问的效率比其高。 |
| 默认扩容方式为原来的2倍。                                    | 底层是自动扩容的动态数组，新的容量为旧的容量的1.5倍 | 底层是双向链表结构                                  |

LinkedList 和 ArrayDeque同为双端队列，LinkedList实现方式为双向链表[无需扩容]，ArrayDeque实现方式为循环数组[访问方式快，每一次扩容两倍]。

ArrayDeque比LinkedList快的原因：

1. 通过下标访问`O(1)`比通过指针`O(n/2)`访问快；
2. LinkedList虽然不需要扩容，但每次插入元素都需要创建一个新节点，经历类加载过程和对象创建过程。

### Queue集合

#### PriorityQueue: 

`Object[]` 数组来实现二叉堆，保证每一次队伍的起点都是最小值、最大值

#### ArrayQueue: 

`Object[]` 数组 + 双指针

### Map集合

1. Map是一种把键对象(key)和值对象(value)进行映射的集合（k-v）。k相当于v的索引，v仍然可以是Map类型(k-v)。
1. key和value都可以是任何==引用类型==的数据。
1. ==key不允许重复==，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。

#### HashMap

1. **数组**里存的是静态内部类
   `Node<K,V>{final int hash; final K key; V value; Node<K,V> next;}`
1. 使用Key映射HashCode，不保证KV对的顺序；
1. 要求覆盖equals()与hashCode()方法；
1. 开散列

> 计算key的hashCode时，`(h = key.hashCode())^(h>>>16)` , 异或高16位与低16位，将高区&低区的二进制特征保存到低区；
>
> - 计算hashmap数组槽位 `map[(n-1)&(hash)]` ,hash为上文中的h，n为数组length；
>
> - ![image-20210730160428566](https://s2.loli.net/2022/07/09/KHb6nxOCd4WVPek.png)
> - n为2^n，否则会丢失很多细节；（e.g ：n=17，n-1~(2)~ = 10000,与hash做&运算时丢失细节；

##### putVal函数详解：

1. 若是首次执行函数，则通过`resize()`初始化table大小，将其初始化为`DEFAULT_INITIAL_CAPACITY = 1 << 4 //aka 16`,同时根据`DEFAULT_LOAD_FACTOR = 0.75f`设置阈值（0.75 * 当前Capacity）；

1. 根据`hash & (n-1)`获取index

   1. 如果当前index没有放对象，则直接放在当前位置
   1. 如果当前index已有对象：
      1. 检查是否是同一个对象`==`，或者`a.equals(b)`，不添加;
      1. 判断当前节点是红黑树，是的话调用
         `((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value)`
      1. 当前节点是链表，顺着链表循环比较是否是同一个对象`==`，或者`a.equals(b)`
         1. 如果是，break不添加
         1. 循环到末尾后，添加当前对象到链表末尾；如果加入后链表长度大于8则调用
            `treeifyBin(tab, hash)` 转化为红黑树。
         1. 在`treeifyBin`中，只有table大小大于64时才会树化当前链表，否则`resize`扩容；

1. 检查存放后是否超过阈值，是则调用`resize()`；

   > 注意：不是table中被占用的index到达阈值，而是所有在table中的对象（包括链表中的）到达阈值；

1. 返回`null`，代表成功，如果返回一个`V oldValue`，代表失败;



开散列冲突：

如果冲突数量小于8，则是以链表方式解决冲突。

而当冲突大于等于8时，就会将冲突的Entry转换为**红黑树**进行存储。

而又当数量小于6时，则又转化为链表存储。

**解决hash冲突问题：**

1. 开放定址法
   1. 线性探测(Linear probing)：``h(x)=(Hash(x)+1)mod(Hashtable.length)`
   1. 平方检测法：`h(x)=(Hash(x)+i)mod(Hashtable.length) ` i 分别为+$a^2 ,-a^2$ (a自增
      从而实现双向检测
1. 再哈希法（rehash）：同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止。虽然不易发生聚集，但是增加了计算时间。
1. 链地址法：HashMap实际使用的方法；
1. 建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。

> 首先JDK1.7的HashMap当出现hash碰撞的时候，最后插入的元素会放在前面，这个称为 “头插法”。但头插法会造成[死链](https://blog.csdn.net/chenyiminnanjing/article/details/82706942)，最后就换成了尾插法（在链表尾部插入节点）。

#### LinkedHashMap

1. 使用==双向链表==维护KV对的顺序，集合排序与插入的顺序保持一致；
1. 键值对节点：

```java
Entry<K,V> extends HashMap.Node<K,V> {
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
```

#### TreeMap

1. 使用红黑树结构，每个key-value对即作为红黑树的一个节点；
1. 实现了SortedMap接口，能对key进行排序；
1. TreeMap可以保证所有的key-value对处于有序状态，自然排序or定制排序；

#### ConcurrentHashMap：

ConcurrentHashMap是线程安全的：通过继承==ReentrantLock==（JDK1.7重入锁）和==synchronized==(JDK1.8内置锁)来进行加锁（分段锁），每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。

1. ConcurrentHashMap采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在这个片段上面进行插入，而且这里还需要获取segment锁。
   ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。
1. **JDK1.8 的时候已经摒弃了 `Segment` 的概念，而是直接用 `Node` 数组+链表+红黑树的数据结构来实现，并发控制使用 `synchronized` 和 CAS 来操作。（JDK1.6 以后 对 `synchronized` 锁做了很多优化）** 整个看起来就像是优化过且线程安全的 `HashMap`，虽然在 JDK1.8 中还能看到 `Segment` 的数据结构，但是已经简化了属性，只是为了兼容旧版本；

ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部，==因此，这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长，但是带来的好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment==。

总的Map包含了16个Segment（默认数量），每个Segment内部包含16个HashEntry（默认数量），这样对于这个key所在的Segment加锁的同时，其他15个Segmeng还能正常使用，在性能上有了大大的提升。

同时ConcurrentHashMap只是针对put方法进行了加锁，而对于get方法并没有采用加锁的操作，因为具体的值，在Segment的HashEntry里面是volatile的，基于happens-before（先行发生）原则，对数据的写先行发生于对数据的读，所以再读取的时候获取到的必然是最新的结果。

#### 小结：

1. Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类；
1. HashMap和Hashtable（继承自dictionary、已弃用）的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的<u>线程同步控制</u>；
1. TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)；
1. HashMap是线程不安全的，不支持并发操作；ConcurrentHashMap支持；

------

retry:标记的下一行就是for循环，在for循环里面调用continue（或者break）再紧接着retry标记时，就表示从这个地方开始执行continue（或者break）操作

# 反射（Reflection）

<img src="https://s2.loli.net/2022/07/09/qYZED8TWpJUFH4k.png" alt="image-20210730190957439" style="zoom:67%;" />

### Class:获取类

jvm创建class实例（class的构造函数为private），与引用类型相关联；

<img src="https://s2.loli.net/2022/07/09/BwXARyQEVOJGC74.png" alt="image-20210729153759410" style="zoom:67%;" />

因此，我们可以通过`Class`实例获取到该实例对应的`class`的所有信息。这种通过`Class`实例获取`class`信息的方法称为==反射（Reflection）==。（基本类型不是class，不能获取）

如何获取一个`class`的`Class`实例？有三个方法：

> 一：直接通过**一个`class`的静态变量`class`**获取：
>
> ```java
> Class cls = String.class;
> ```
>
> 二：如果我们有一个**实例变量**，可以通过该实例变量提供的`getClass()`方法获取：
>
> ```java
> String s = "Hello";
> Class cls = s.getClass();
> ```
>
> 三：如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取：
>
> ```java
> Class cls = Class.forName("java.lang.String");
> ```

<u>所有`Class`实例在JVM中是唯一的</u>，所以，上述方法获取的`Class`实例是同一个实例。

可以用 `==` 、 `instanceof ` 比较两个类型实例：

```java
//instanceof 比较常用，因为面向对象抽象编程时，我们不关心具体的子类型；
Integer n = new Integer(123);
boolean b1 = n instanceof Integer; // true
boolean b2 = n instanceof Number; // true，因为n是Number类型的子类
boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class
```

==JVM动态加载class==——第一次需要用到时才加载，利用此特性，能在运行期根据条件加载不同的实现类。

------

### Field:访问字段

对于任意一个Object实例，只要获取了他的class，就可以获取它的一切信息。

```java
import java.lang.reflect.Field;
//获取字段的方式
Field getField(name)//根据字段名获取某个public的field（包括父类）
Field getDeclaredField(name)//根据字段名获取当前类的某个field（不包括父类、包括private）
Field[] getFields()//获取所有public的field（包括父类）
Field[] getDeclaredFields()//获取当前类的所有field（不包括父类）

//e.g    
Class stdClass = Student.class;
stdClass.getField("score");
```

#### 获取字段信息：

一个Field对象包含了一个字段的所有信息，我们用反射获取该字段的信息，代码如下：

```java
//函数
Field.getName()//返回字段名称，例如，"name"；
Field.getType()//返回字段类型，也是一个Class实例，例如，String.class；
Field.getModifiers()//返回字段的修饰符，它是一个int，不同的bit表示不同的含义。
```

以String类的value字段为例，它的定义是：

```java
public final class String {
    private final byte[] value;
}

Field f = String.class.getDeclaredField("value");
f.getName(); // "value"
f.getType(); // class [B 表示byte[]类型
int m = f.getModifiers();
Modifier.isFinal(m); // true
Modifier.isPublic(m); // false
Modifier.isProtected(m); // false
Modifier.isPrivate(m); // true
Modifier.isStatic(m); // false
```

#### 获取字段值：

```java
Object p = new Person("XiaoMing");
Class c = p.getClass();
Field f = c.getDeclaredField("name");
f.setAccessible(true);
//name为private字段，正常情况下无法访问；f.setAccessible(true)后一律允许访问
//如果JVM运行期存在securityManager，可能setAccessible会失败
Object value = f.get(p);
```

#### 设置字段值：

```java
//接上文
f.set(p,"Xiao Hong");
```

------

### Method:调用方法

```java
Method getMethod(name, Class...)//获取某个public的Method（包括父类）
Method getDeclaredMethod(name, Class...)//获取当前类的某个Method（不包括父类）
Method[] getMethods()//获取所有public的Method（包括父类）
Method[] getDeclaredMethods()//获取当前类的所有Method（不包括父类）
```

```java
public class Main {
    public static void main(String[] args) throws Exception {
        Class stdClass = Student.class;
        // 获取public方法getScore，参数为String:
        System.out.println(stdClass.getMethod("getScore", String.class));
        // 获取继承的public方法getName，无参数:
        System.out.println(stdClass.getMethod("getName"));
        // 获取private方法getGrade，参数为int:	
        System.out.println(stdClass.getDeclaredMethod("getGrade", int.class));
    }
}
```

一个`Method`对象包含一个方法的所有信息：

- `getName()`：返回方法名称，例如：`"getScore"`；
- `getReturnType()`：返回方法返回值类型，也是一个Class实例，例如：`String.class`；
- `getParameterTypes()`：返回方法的参数类型，是一个Class数组，例如：`{String.class, int.class}`；
- `getModifiers()`：返回方法的修饰符，它是一个`int`，不同的bit表示不同的含义。

```java
public class Main {
    public static void main(String[] args) throws Exception {
        // String对象:
        String s = "Hello world";
        // 获取String substring(int)方法，参数为int:
        Method m = String.class.getMethod("substring", int.class);
        // 在s对象上调用该方法并获取结果:
        String r = (String) m.invoke(s, 6);
        // 打印调用结果:
        System.out.println(r);
    }
}
```

1. 调用静态方法：

   无需指定实例对象.以`Integer.parseInt(String)`为例：

   ```java
   Integer n = (Integer) m.invoke(null, "12345");
   ```

1. 调用非public方法：

   通过`Class.getDeclaredMethod()`获取该方法实例，但直接对其调用将得到一个`IllegalAccessException`。为了调用非public方法，我们通过`Method.setAccessible(true)`允许其调用：

1. 多态：

   使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：

   ```java
   Method m = Person.class.getMethod("hello");
   m.invoke(new Student());
   //相当于：
   Person p = new Student();
   p.hello();
   ```

------

### Constructor：调用构造方法

- 通过反射建立实例：调用class提供的无参数构造方法——newInstance();
- newInstance()只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法==直接==通过Class.newInstance()来调用。【先利用getConstructor()找到特定构造方法，再调用】

```java
//无参
Person p = Person.class.newInstance();
// 获取构造方法Integer(int):
Constructor cons1 = Integer.class.getConstructor(int.class);
// 调用构造方法:
Integer n1 = (Integer) cons1.newInstance(123);
System.out.println(n1);

// 获取构造方法Integer(String)
Constructor cons2 = Integer.class.getConstructor(String.class);
Integer n2 = (Integer) cons2.newInstance("456");
System.out.println(n2);
```

```java
//通过Class实例获取Constructor的方法如下：
getConstructor(Class...)//获取某个public的Constructor；
getDeclaredConstructor(Class...)//获取某个Constructor；
getConstructors()//获取所有public的Constructor；
getDeclaredConstructors()//获取所有Constructor。
```

调用非public的Constructor时，必须首先<u>通过setAccessible(true)设置允许访问</u>。setAccessible(true)可能会失败。

------

### 获取继承关系

- 获取父类:Class Class.getSuperclass();

- 获取interface: Class.getInterfaces();【只返回直接实现的接口类型，不包括父类实现的接口类型】

- 继承关系：instanceof 操作符

  `boolean isSerializable = n instanceof java.io.Serializable; `

- 判断向上转型是否成立：isAssignableFrom()：

```java
// Integer i = ?
Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer
// Number n = ?
Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number
// Object o = ?
Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object
// Integer i = ?
Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer
```

------

### 动态代理

[接口为什么要实例化](https://www.cnblogs.com/alsf/p/6685607.html)

我们来比较Java的`class`和`interface`的区别：<u>可以实例化`class`（非`abstract`）；不能实例化`interface`</u>。

所有`interface`类型的变量总是通过向上转型并指向某个实例的：

创建接口实例的方法：**静态创建**、**动态创建**。

#### 静态：

```java
//接口：
public interface Hello {
    void morning(String name);
}
//实现类：
public class HelloWorld implements Hello {
    public void morning(String name) {
        System.out.println("Good morning, " + name);
    }
}
//创建实例，转型为接口并调用：
Hello hello = new HelloWorld();
hello.morning("Bob");
```

#### 动态：

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类==( CGLIB 动态代理机制)==。

**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

```java
/*
 *不编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。
 *这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。
 *JDK提供的动态创建接口对象的方式，就叫动态代理。
 */
public class Main {
    public static void main(String[] args) {
        InvocationHandler handler = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                if (method.getName().equals("morning")) {
                    System.out.println("Good morning, " + args[0]);
                }
                return null;
            }
        };
        Hello hello = (Hello) Proxy.newProxyInstance(
            Hello.class.getClassLoader(), // 传入ClassLoader
            new Class[] { Hello.class }, // 传入要实现的接口
            handler); // 传入处理调用方法的InvocationHandler
        hello.morning("Bob");
    }
}
//Good morning, Bob
```

1. 定义一个`InvocationHandler`实例，它负责实现接口的方法调用；
1. 通过`Proxy.newProxyInstance()`创建interface实例，它需要3个参数：
   1. 使用的`ClassLoader`，通常就是接口类的`ClassLoader`，用于加载代理对象；
   1. 需要实现的接口数组，至少需要传入一个接口进去；
   1. 用来处理接口方法调用的`InvocationHandler`实例。
1. 将返回的`Object`强制转型为接口。

动态代理类的字节码在程序运行时，由Java反射机制动态产生。 它会根据需要，通过反射机制在程序运行期，动态的为目标对象创建代理对象

# 注解（Annotation）

- java1.5引入的特性
- 注解是一种用作标注的“元数据”，放在Java源码的类、方法、字段、参数前的一种特殊“注释”：
- 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件；

#### 注解类型：

1. SOURCE类——是**由编译器使用**的注解，例如：

   `@Override `  让编译器检查该方法是否正确地实现了覆写；
   `@SuppressWarnings`   告诉编译器忽略此处代码产生的警告。
   <u>这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了</u>。

1. CLASS类——是**由工具处理.class文件使用**的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会<u>被编译进入.class文件，但加载结束后并不会存在于内存中</u>。这类注解只被一些底层库使用，一般我们不必自己处理。

1. ==RUNTIME类==——是**在程序运行期能够读取的注解**，它们在<u>加载后一直存在于JVM中</u>，这也是最常用的注解。例如，一个配置了`@PostConstruct`的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。

#### 注解作用：

1. 生成文档。这是最常见的，也是java 最早提供的注解。常用的有 `@see @param @return `等 
1. 跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。 
1. 在编译时进行格式检查。如`@override `放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。

#### 配置参数：

1. 所有基本类型；
1. String；
1. 枚举类型；
1. 基本类型、String、Class以及枚举的数组。

```java
//注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。
public class Hello {
    @Check(min=0, max=100, value=55)
    public int n;

    @Check(value=99)
    public int p;

    @Check(99) // @Check(value=99)
    public int x;

    @Check//只写注解，表示所有参数都使用默认值。
    public int y;
    }
```

#### 定义注解：

注解本质是一个继承了`Annotation` 的特殊接口：

```java
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
//注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。
```

##### 元注解（meta annotation）

可以==修饰其他注解==。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。

**@Target     定义Annotation能够被应用于源码的哪些位置：**

> 类或接口：ElementType.TYPE；
> 字段：ElementType.FIELD；
> 方法：ElementType.METHOD；
> 构造方法：ElementType.CONSTRUCTOR；
> 方法参数：ElementType.PARAMETER。

```java
//定义注解@Report可用在方法或字段上
//@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：
//实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。
@Target({
    ElementType.METHOD,
    ElementType.FIELD
})
public @interface Report {
    ...
}
```

**@Retention     定义了Annotation的生命周期：**

> 仅编译期：RetentionPolicy.SOURCE；
> 仅class文件：RetentionPolicy.CLASS；【default】
> 运行期：RetentionPolicy.RUNTIME。
> 通常我们自定义的Annotation都是RUNTIME，所以==一定要加上@Retention(RetentionPolicy.RUNTIME)==这个元注解：

```java
@Retention(RetentionPolicy.RUNTIME)
public @interface Report {
    int type() default 0;
    String level() default "info";
    String value() default "";
}
```

**@Repeatable    定义Annotation是否可重复【应用不广泛】：**

```java
@Repeatable(Reports.class)
@Target(ElementType.TYPE)
public @interface Report {
    ...
}
@Target(ElementType.TYPE)
public @interface Reports {  //此处为“reports”
    Report[] value();
}
//经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：
@Report(type=1, level="debug")
@Report(type=2, level="warning")
public class Hello {
}
```

**@Inherited   定义子类是否可继承父类定义的Annotation：**

仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对==class==的继承，对interface的继承无效：

```java
@Inherited
@Target(ElementType.TYPE)
public @interface Report {
    ...
}
```

使用的时候，如果一个类用到了@Report：则它的子类默认也定义了该注解：

##### 步骤：

1. 第一步，用`@interface`定义注解：

1. 第二步，添加参数、默认值：

1. 第三步，用元注解配置注解：

   > 必须设置@Target和@Retention；
   >
   > @Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取；
   >
   > 一般情况下，不必写@Inherited和@Repeatable。

#### 处理注解

<u>注解定义后也是一种class，继承自java.lang.annotation.Annotation</u>，因此，读取注解需要使用**反射API**。

```java
//判断某个注解是否存在于Class、Field、Method或Constructor：
Class.isAnnotationPresent(Class)
Field.isAnnotationPresent(Class)
Method.isAnnotationPresent(Class)
Constructor.isAnnotationPresent(Class)
    
// 判断@Report是否存在于Person类:
Person.class.isAnnotationPresent(Report.class);

//使用反射API读取Annotation：
Class.getAnnotation(Class)
Field.getAnnotation(Class)
Method.getAnnotation(Class)
Constructor.getAnnotation(Class)

// 获取Person定义的@Report注解:
Report report = Person.class.getAnnotation(Report.class);
int type = report.type();
String level = report.level();
```

使用反射API读取Annotation的两种方法：

```java
//一是先判断Annotation是否存在，如果存在，就直接读取：
Class cls = Person.class;
if (cls.isAnnotationPresent(Report.class)) {
    Report report = cls.getAnnotation(Report.class);
    ...
}

//二是直接读取Annotation，如果Annotation不存在，将返回null：
Class cls = Person.class;
Report report = cls.getAnnotation(Report.class);
if (report != null) {
   ...
}
```

读取**方法、字段和构造方法**的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点。<u>因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解</u>，所以，**一次获取方法参数的所有注解就必须用一个==二维数组==来表示。**

```java
//例如，对于以下方法定义的注解：
public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {
}
```

要读取方法参数的注解，我们**先用反射获取Method实例，然后读取方法参数的所有注解**：

```java
// 获取Method实例:
Method m = ...
// 获取所有参数的Annotation:
Annotation[][] annos = m.getParameterAnnotations();
// 第一个参数（索引为0）的所有Annotation:
Annotation[] annosOfName = annos[0];
for (Annotation anno : annosOfName) {
    if (anno instanceof Range) { // @Range注解
        Range r = (Range) anno;
    }
    if (anno instanceof NotNull) { // @NotNull注解
        NotNull n = (NotNull) anno;
    }
}
```

##### 使用注解

我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Range {
    int min() default 0;
    int max() default 255;
}

//在某个JavaBean中，我们可以使用该注解：
public class Person {
    @Range(min=1, max=20)
    public String name;
 	@Range(max=10)
 	public String city;

}
/*定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。
这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：
*/
void check(Person person) throws IllegalArgumentException, ReflectiveOperationException {
    // 遍历所有Field:
    for (Field field : person.getClass().getFields()) {
        // 获取Field定义的@Range:
        Range range = field.getAnnotation(Range.class);
        // 如果@Range存在:
        if (range != null) {
            // 获取Field的值:
            Object value = field.get(person);
            // 如果值是String:
            if (value instanceof String) {
                String s = (String) value;
                // 判断值是否满足@Range的min/max:
                if (s.length() < range.min() || s.length() > range.max()) {
                    throw new IllegalArgumentException("Invalid field: " + field.getName());
                }
            }
        }
    }
}
```

![img](https://s2.loli.net/2022/07/09/hxWqatRcknlzSv5.jpg)

# JVM

 Java编写的程序都运行在在Java虚拟机（JVM）中，每用java命令启动一个java应用程序，就会启动一个JVM进程。在同一个JVM进程中，有且只有一个进程，就是它自己。

### java内存区域（运行时数据区域）：

<img src="https://s2.loli.net/2022/07/09/R5B3vkIAUOcetYG.png" alt="img" style="zoom:80%;" />

**线程私有的：**

- 程序计数器

  > 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。**字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令。**
  >
  > **程序计数器主要有两个作用：**
  >
  > 1. 字节码解释器==通过改变程序计数器来依次读取指令==，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
  > 1. 在==多线程的情况下，程序计数器用于记录当前线程执行的位置==，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
  >
  > **注意：程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。**

- 虚拟机栈

  > **生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。**
  >
  > 每个方法被执行的时候，Java虚拟机都会同步创建一个==栈帧==（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如==局部变量表、操作数栈、动态链接、方法出口==等。
  >
  > <u>局部变量表</u>主要存放了**编译期可知**的基本类型、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
  >
  > **Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。**
  >
  > - **`StackOverFlowError`：** 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
  > - **`OutOfMemoryError`：** Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。

- 本地方法栈

  > 和虚拟机栈非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。
  >
  > 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
  >
  > 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和 `OutOfMemoryError` 两种错误。

**线程共享的：**

- 堆

  > Java 虚拟机所管理的==内存中最大的一块==，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
  >
  > Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。**进一步划分的目的是更好地回收内存，或者更快地分配内存。**
  >
  > 在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：新生代内存(Young Generation)、老生代(Old Generation)、永久代(Permanent Generation)。
  >
  > ![image-20220222151708141](https://s2.loli.net/2022/07/09/AJGbmzuoFXw5dvk.jpg)
  >
  > **JDK 8 版本之后<u>永久代</u>已被 Metaspace(元空间) 取代，元空间使用的是直接内存。**

- 方法区

  > 方法区与 Java 堆一样，是各个线程共享的内存区域，大致可以分为两个部分：==类信息表==和==运行时常量池==。它用于存储已被==虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据==。**方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。**
  >
  > <img src="https://s2.loli.net/2022/07/09/MZ3WnbFq7Nco6sO.jpg" alt="image-20220201140516096" style="zoom: 50%;" />
  >
  > **为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?**
  >
  > 1.整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
  >
  > 2.元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样==能加载的类就更多了==。
  >
  > 1. 运行时常量池
  >
  >    ![image-20220223130536357](https://s2.loli.net/2022/07/09/Ioa6ZbXc9uAtdKU.jpg)

- 直接内存 (非运行时数据区的一部分）

  > **直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。**本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。
  >
  > 直接内存即==申请堆外内存==，运用到一个堆外内存操作类：`Unsafe`。直接内存实际上就是JVM申请的一块额外的内存空间，但是它并不在受管控的几种内存空间中，当然这些内存依然属于是JVM的，由于JVM提供的堆内存会进行垃圾回收等工作，效率不如直接申请和操作内存来得快，一些比较追求极致性能的框架会用到堆外内存来提升运行速度，如nio框架。

### 对象的创建：

![image-20220709175302797](https://s2.loli.net/2022/07/09/7vyDM1c54Ts2NQA.png)

#### Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查**这个指令的参数是否能在常量池中定位到这个类的符号引用**，并且==检查这个符号引用代表的类是否已被加载过、解析和初始化过==。如果没有，那必须先执行相应的类加载过程。

#### Step2:分配内存

在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 。

1. 指针碰撞：
   - 适用场合：在堆内存规整（即没有内存碎片)的情况下
   - 原理：将内存全部整合到一边，没有用过的内存放另一边，中间有一个分界值指针，只需要向没用过的方向将该指针移动对象内存大小位置即可。
   - GC收集器：Serial、ParNew
1. 空闲列表：
   - 适用场合：在堆内存不规整的情况下
   - 原理：虚拟机会维护一个列表，该列表记录哪些内存块是可用的，在分配的时候，找一块足够大的内存块来划分给对象实例，最后更新列表记录
   - GC收集器：CMS

**内存分配并发问题**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**
- **TLAB：** 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配

#### Step3:初始化零值

内存分配完成后，==虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）==，这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

#### Step4:设置对象头

初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

#### Step5:执行 init 方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 对象的访问定位

建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有==① 使用句柄==和==② 直接指针==两种：

1. **句柄：** 如果使用句柄的话，那么 <u>Java 堆中将会划分出一块内存来作为句柄池</u>，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

   ![对象的访问定位-使用句柄](https://s2.loli.net/2022/07/09/8CTFREVfUQN2Au7.png)

1. **直接指针：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。

![对象的访问定位-直接指针](https://s2.loli.net/2022/07/09/d1saXxyvZoBzh8n.png)

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

## 垃圾回收：

### 分代垃圾收集算法:

![img](https://s2.loli.net/2022/07/09/b9QAWlOrIwua7Hp.png)

对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到对象晋升到老年代的年龄阈值（默认为大于 15 岁），就会被晋升到老年代中。这个值会在虚拟机运行过程中进行调整。

Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值。

> 大对象直接进入老年代，避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

**在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**

##### 主要进行gc的区域：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。

### 垃圾收集算法：

#### 标记-清除算法

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

1. **效率问题**
1. **空间问题（标记清除后会产生大量不连续的碎片）**

<img src="https://s2.loli.net/2022/07/09/zYR5VMm94nAvQN6.jpg" alt="img" style="zoom:50%;" />

#### 标记-复制算法

为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

<img src="https://s2.loli.net/2022/07/09/yG67vEJVhulYteC.jpg" alt="复制算法" style="zoom:50%;" />

#### 标记-整理算法

根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

<img src="https://s2.loli.net/2022/07/09/YJnkVO1m3GBc4H2.jpg" alt="标记-整理算法 " style="zoom:67%;" />

### 垃圾收集器：

Serial收集器：单线程

![image-20220223104605648](https://s2.loli.net/2022/07/09/XprL2M5KODCf9AS.jpg)

ParNew收集器：Serail的多线程版本

![image-20220223111344962](https://s2.loli.net/2022/07/09/OKuJzUeQ9YZwjrD.jpg)

Parallel Scavenge/Parallel Old收集器：

面向新生代的垃圾收集器，同样采用标记复制算法实现，在JDK6时也推出了其老年代收集器Parallel Old，采用标记整理算法实现。与ParNew收集器不同的是，==它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间==。**目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old 的垃圾回收方案。**

![image-20220223112108949](https://s2.loli.net/2022/07/09/mNfAwzltcgECQeX.jpg)

#### CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以==获取最短回收停顿时间为目标==的收集器。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，==第一次实现了让垃圾收集线程与用户线程（基本上）同时工作==。（使用在老年代）

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”算法**实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
- **重新标记：** 由于并发标记阶段可能某些用户线程会导致标记产生变得，因此这里需要再次暂停所有线程进行并行标记，这个时间会比初始标记时间长一丢丢。
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![image-20220223114019381](https://s2.loli.net/2022/07/09/9XAUNdhvZTw7p58.jpg)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生**

#### G1 收集器

**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**

被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

==G1收集器将整个Java堆划分成2048个大小相同的独立Region块==，每个Region块的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的Region大小相同，且在JVM的整个生命周期内不会发生改变。

每一个Region都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个Humongous区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的。
![image-20220223123636582](https://s2.loli.net/2022/07/09/L7YfUNyhnXCuoBJ.jpg)

![image-20220223123557871](https://s2.loli.net/2022/07/09/nFMlDVHtSBhfQ5Z.jpg)

- 初始标记（暂停用户线程）：仅仅只是标记一下GC Roots能直接关联到的对象，并且==修改TAMS指针的值==，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

- 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。
- 最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象。
- 筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的。

### 空间分配担保

空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。

![image-20220222205605690](https://s2.loli.net/2022/07/09/omTksX4W3gpMrzn.jpg)

### 判断对象是否死亡：

堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）

#### 引用计数法：

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。** 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

#### 可达性分析算法

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

<img src="https://s2.loli.net/2022/07/09/8OAdYsLCN3k2MQD.png" alt="image-20220324011706445" style="zoom:67%;" />

**哪些对象可以作为 GC Roots 呢？**

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
1. 本地方法栈(Native 方法)中引用的对象
1. 方法区中类静态属性引用的对象 static
1. 方法区中常量引用的对象 final
1. 所有被同步锁持有的对象
1. 虚拟机内部需要用到的对象。

###  如何判断一个常量是废弃常量

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。

### 如何判断一个类是无用的类

方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
1. 加载该类的 `ClassLoader` 已经被回收。
1. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收

### 引用：

#### 1．强引用（StrongReference）

`Object o = new Object()`当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

#### 2．软引用（SoftReference）

`SoftReference<Object> reference = new SoftReference<>(new Object())`当 JVM 认为内存不足时，会去试图回收软引用指向的对象，即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。<u>软引用可用来实现内存敏感的高速缓存。</u>

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

#### 3．弱引用（WeakReference）

一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### 4．虚引用（PhantomReference）

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

## 类加载机制

![image-20220224132621764](https://s2.loli.net/2022/07/09/baOvhemHU9wXKFN.jpg)

一般在这些情况下，如果类没有被加载，那么会被自动加载：

1. 使用**new关键字**创建对象时
1. 使用某个类的**静态成员**（包括方法和字段）的时候（当然，final类型的静态字段有可能在编译的时候被放到了当前类的常量池中，这种情况下是不会触发自动加载的）
1. 使用**反射**对类信息进行获取的时候（之前的数据库驱动就是这样的）
1. 加载一个类的**子类**时（会自动调用父类的构造函数）
1. 加载接口的实现类，且接口带有default的方法默认实现时

### 加载

**类加载的过程：**==首先获得此类的二进制数据，然后交给类的加载器进行加载，类的所有信息会被加载到方法区中，并且在堆内存中生成一个代表当前类的Class对象；==

**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**

> 加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

### 验证

![验证阶段示意图](https://s2.loli.net/2022/07/09/fudskKQp5ojDZEl.png)

### 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。注意是系统规定的初始值，不是我们手动指定的初始值。

### 解析

解析阶段是虚拟机==将常量池内的符号引用替换为直接引用==的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

符号引用就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 初始化

初始化阶段是执行初始化方法 `<clinit> ()`方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。

> 说明： `<clinit> ()`方法是编译之后自动生成的。

对于`<clinit> ()` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit> ()` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。

对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：

1. 当遇到 new getstatic putstatic invokestatic 这 4 条直接码指令时，比如new一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
   - 当 jvm 执行 `new` 指令时会初始化类。即当程序创建一个类的实例对象。
   - 当 jvm 执行 `getstatic` 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
   - 当 jvm 执行 `putstatic` 指令时会初始化类。即程序给类的静态变量赋值。
   - 当 jvm 执行 `invokestatic` 指令时会初始化类。即程序调用类的静态方法。
1. 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
1. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
1. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
1. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
1. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 卸载

卸载类即该类的 Class 对象被 GC。在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk 自带的 `BootstrapClassLoader`, `ExtClassLoader`, `AppClassLoader` 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

## 类加载器

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`：

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由 C++实现，负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。
1. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。
1. **AppClassLoader(应用程序类加载器)** ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

### 双亲委派模型介绍

每一个类都有一个对应它的类加载器。系统中的 ClassLoader 在协同工作的时候会默认使用 **双亲委派模型** 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 `BootstrapClassLoader` 作为父类加载器。

<img src="https://s2.loli.net/2022/07/09/THoP76ntR1vF2cw.png" alt="ClassLoader" style="zoom:80%;" />

## java内存模型（JMM）：

Java内存模型(java Memory Model)描述了Java程序中各种变量(**线程共享变量**)的访问规则，以及在JVM中将变量**存储到内存**和从**内存中读取出变量**这样的底层细节。线程对共享变量的操作，遵循一下两条规则：

1. 线程对**共享变量**的所有操作都必须在**自己的工作内存**中进行，不能直接从**主内存**中读写
1. 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过**主内存**来完成

<img src="https://s2.loli.net/2022/07/09/Y8bLJ7kuTX9iNUF.jpg" alt="img" style="zoom: 67%;" />

（这里的工作内存是指高速缓存，主内存是指磁盘）

> - **可见性**：一个线程对共享变量值的修改，能够及时地被其他线程看到。
>
>   <img src="https://s2.loli.net/2022/07/09/G9Ssa8RixcFbdXD.jpg" alt="img" style="zoom:50%;" />
>
> - **原子性：**把一个事务可看作是一个程序,它要么完整的被执行,要么完全不执行。
>
> - **共享变量**：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。

# 设计模式

1. **观察者模式：**定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。

   - Observer会实现接收消息变化的类，Subjector内部有一个集合存储其订阅者，循环该集合发送更新信息；

1. **工厂模式：**

   1. **静态工厂模式：**类+静态方法。（单例）
   1. **简单工厂模式：**通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。
   1. **工厂方法模式：**有四个角色，==抽象工厂，具体工厂，抽象产品，具体产品==。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品
   1. **抽象工厂模式：**与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品。（之前是一个工厂一个生产函数、现在工厂可以生产多个函数）

1. **单例设计模式：**为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而**使用单例模式能够保证整个应用中有且只有一个实例**。目标：同时满足懒加载和线程安全；

   - 懒汉式、饿汉式、静态内部类、枚举类、双重校验锁
     预加载：饿汉式、枚举类、（保证线程安全）
     延迟加载：懒汉式，但不能保证只实例化一次（除非给getInstance函数上锁）；双重校验锁；静态内部类；

     ```java
     public class Singleton {  
         private static class SingletonHolder {  
         private static final Singleton INSTANCE = new Singleton();  
         }  
         private Singleton (){}  
         public static final Singleton getInstance() {  
             return SingletonHolder.INSTANCE;  
         }  
     }//j
     ```

1. **装饰者模式：**对已有的业务逻辑进一步的封装，使其增加额外的功能。

   - 有一个类作为基类，其他类继承该基类并且增加一些额外的功能（装饰类），最后给需要的装饰类传子类从而达到装饰需求；

1. **适配器模式：**一个xxxAdapter类（适配器类），传给需要拥有适配器的类；

1. **代理模式：**

   1. **静态代理：**有一个代理接口，代理类和被代理类都会实现该接口，代理类在代理方法中实现增强；
   1. **动态代理：**java提供了一个`Proxy`类，调用它的`newProxyInstance`方法可以生成某个对象的代理对象，该方法需要三个参数：`(ClassLoader loader, Class<?>[] interface, reflect.InvocationHandler)`即被代理类的装载器、指定要被代理类的接口、<u>实现handler接口</u>指定接口的内容；

> 静态代理与动态代理的区别：
>
> 1.静态代理需要自己编写，工作量大；动态代理不需要，而是利用JDK API，动态的在内存中构建代理方法，并会默认实现接口的全部方法。
>
> 2.

# Linux

1.什么是内核？

内核是操作系统的心脏。它充当软件和硬件之间的桥梁。如果软件请求硬件，则内核将在软件和硬件之间传递数据。例如播放一首歌曲，则默认播放器会请求内核播放一首歌曲，内核将与硬件联系以寻求许可或寻求硬件组件。大多数Android手机使用Linux内核。 内核可以编辑，因为它是根据通用公共许可证发行的。

2.什么是shell？

Shell是一个计算机程序，==充当用户和内核之间的接口。==用户可以通过在Shell上编写**程序，命令和脚本**来与内核进行通信。它接受人类可读的命令，并将其转换为内核可理解的语言。

3.解释Linux中的流程管理系统调用吗？

**回答：**  Linux中的流程管理系统调用：

- **fork（）：**用于创建新进程。
- **exec（）：**执行新进程。
- **wait（）：**等到进程执行。
- **exit（）：**退出进程。

系统调用以获取进程ID：

- **getpid（）：**查找唯一的进程ID。 
- **getppid（）：**查找唯一的父进程ID

4.常用命令：

检查系统在监听哪个端口?netstat --listen

查看当前网络状态？ifconfig

查看cpu信息？cat /proc/cpuinfo

查看进程命令？ps -ef|grep tomcat （查询tomcat进程）











